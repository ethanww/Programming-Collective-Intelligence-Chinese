<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="keywords" content="X86 assembly language,1990s,3DNow!,8008,80286,80386,80486DX,8086,AMD,AMD64,Assembly language" />
<link rel="shortcut icon"  />
<link rel="search" type="application/opensearchdescription+xml"  />
<link rel="copyright"  />
		<title>X86 assembly language - Wikipedia, the free encyclopedia</title>
		<style type="text/css" media="screen,projection">/*<![CDATA[*/ @import "/skins-1.5/monobook/main.css?9"; /*]]>*/</style>
		<link rel="stylesheet" type="text/css" media="print"  />
		<!--[if lt IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE50Fixes.css";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE55Fixes.css";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/skins-1.5/monobook/IE60Fixes.css";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/skins-1.5/monobook/IE70Fixes.css?1";</style><![endif]-->
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
		
		<script type= "text/javascript">
			var skin = "monobook";
			var stylepath = "/skins-1.5";

			var wgArticlePath = "/wiki/$1";
			var wgScriptPath = "/w";
			var wgServer = "http://en.wikipedia.org";
                        
			var wgCanonicalNamespace = "";
			var wgNamespaceNumber = 0;
			var wgPageName = "X86_assembly_language";
			var wgTitle = "X86 assembly language";
			var wgArticleId = 214948;
			var wgIsArticle = true;
                        
			var wgUserName = null;
			var wgUserLanguage = "en";
			var wgContentLanguage = "en";
		</script>
		                
		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?1"><!-- wikibits js --></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js"><!-- site js --></script>
		<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Common.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=MediaWiki:Monobook.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=-&action=raw&gen=css&maxage=2678400";
/*]]>*/</style>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js"></script>
	</head>
<body  class="mediawiki ns-0 ltr">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><div style="text-align:right; font-size:80%">Your <b><a  class="extiw" title="wikimedia:Fundraising">continued donations</a></b> keep Wikipedia running!&nbsp;&nbsp;&nbsp;&nbsp;</div>
</div>		<h1 class="firstHeading">X86 assembly language</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a >navigation</a>, <a >search</a></div>			<!-- start content -->
			<div class="messagebox cleanup metadata"><b>To meet Wikipedia's <a  title="Category:Wikipedia style guidelines">quality standards</a>, this article or section may require <a  title="Wikipedia:Cleanup">cleanup</a>.</b><br />
<span style="font-size: 90%">Please discuss this issue on the <a  title="Talk:X86 assembly language">talk page</a>, or replace this tag with a <a  title="Wikipedia:Template messages/Cleanup">more specific message</a>. <a  title="Help:Editing">Editing help</a> is available.<br />
This article has been tagged since <b>November 2005</b>.</span></div>
<p><br /></p>
<dl>
<dd><span class="plainlinks"><i>The correct title of this article is <b>x86 assembly language</b>. The initial letter is capitalized due to <a  title="Wikipedia:Naming conventions (technical restrictions)">technical restrictions</a>.</i></span></dd>
</dl>
<div class="infobox sisterproject">
<div style="float: left;">
<div class="floatnone"><span><a  class="image" title="Wikibooks"><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/7c/Wikibooks-logo-en.svg/50px-Wikibooks-logo-en.svg.png" alt="Wikibooks" width="50" height="57" longdesc="/wiki/Image:Wikibooks-logo-en.svg" /></a></span></div>
</div>
<div style="margin-left: 60px;"><a  class="extiw" title="wikibooks:">Wikibooks</a> has more about this subject:
<div style="margin-left: 10px;"><i><b><a  class="extiw" title="wikibooks:x86_assembly">x86 assembly</a></b></i></div>
</div>
</div>
<div class="messagebox merge">
<div class="floatleft"><span><a  class="image" title=""><img src="http://upload.wikimedia.org/wikipedia/commons/8/8b/Merge-arrows.gif" alt="" width="50" height="20" longdesc="/wiki/Image:Merge-arrows.gif" /></a></span></div>
It has been suggested that this article or section be <a  title="Wikipedia:Merging and moving pages">merged</a> with <i><a href="/wiki/IA-32.html" title="IA-32">IA-32</a></i>. (<a  title="Talk:X86 assembly language">Discuss</a>)</div>
<p><br />
<b>x86 assembly language</b> is the <a href="/wiki/Assembly_language.html" title="Assembly language">assembly language</a> for the <a href="/wiki/X86.html" title="X86">x86</a> class of processors, which includes <a href="/wiki/Intel.html" title="Intel">Intel</a>'s <a href="/wiki/Pentium.html" title="Pentium">Pentium</a> series and <a href="/wiki/AMD.html" title="AMD">AMD</a>'s <a href="/wiki/Athlon.html" title="Athlon">Athlon</a> series.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a ><span class="tocnumber">1</span> <span class="toctext">x86 instruction set architecture</span></a>
<ul>
<li class="toclevel-2"><a ><span class="tocnumber">1.1</span> <span class="toctext">The various kinds of instructions</span></a></li>
<li class="toclevel-2"><a ><span class="tocnumber">1.2</span> <span class="toctext">The stack</span></a></li>
<li class="toclevel-2"><a ><span class="tocnumber">1.3</span> <span class="toctext">Execution modes</span></a>
<ul>
<li class="toclevel-3"><a ><span class="tocnumber">1.3.1</span> <span class="toctext">Real mode</span></a></li>
<li class="toclevel-3"><a ><span class="tocnumber">1.3.2</span> <span class="toctext">Protected mode</span></a></li>
<li class="toclevel-3"><a ><span class="tocnumber">1.3.3</span> <span class="toctext">Long mode</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a ><span class="tocnumber">1.4</span> <span class="toctext">Integer registers</span></a></li>
<li class="toclevel-2"><a ><span class="tocnumber">1.5</span> <span class="toctext">Floating point stack</span></a></li>
<li class="toclevel-2"><a ><span class="tocnumber">1.6</span> <span class="toctext">SIMD registers</span></a>
<ul>
<li class="toclevel-3"><a ><span class="tocnumber">1.6.1</span> <span class="toctext">MMX</span></a></li>
<li class="toclevel-3"><a ><span class="tocnumber">1.6.2</span> <span class="toctext">3DNow!</span></a></li>
<li class="toclevel-3"><a ><span class="tocnumber">1.6.3</span> <span class="toctext">Streaming SIMD extensions</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a ><span class="tocnumber">2</span> <span class="toctext">Instruction overview</span></a>
<ul>
<li class="toclevel-2"><a ><span class="tocnumber">2.1</span> <span class="toctext">Integer ALU instructions</span></a></li>
<li class="toclevel-2"><a ><span class="tocnumber">2.2</span> <span class="toctext">Floating point instructions</span></a></li>
<li class="toclevel-2"><a ><span class="tocnumber">2.3</span> <span class="toctext">SIMD instructions</span></a></li>
<li class="toclevel-2"><a ><span class="tocnumber">2.4</span> <span class="toctext">Data manipulation instructions</span></a></li>
<li class="toclevel-2"><a ><span class="tocnumber">2.5</span> <span class="toctext">Programming flow</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a ><span class="tocnumber">3</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">4</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<p><script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script></p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: x86 instruction set architecture">edit</a>]</div>
<p><a name="x86_instruction_set_architecture" id="x86_instruction_set_architecture"></a></p>
<h2>x86 instruction set architecture</h2>
<p>The x86 processor and <a href="/wiki/Instruction_set.html" title="Instruction set">instruction set</a> design is <a href="/wiki/Complex_instruction_set_computer.html" title="Complex instruction set computer">CISC</a>; however, in the latter half of the <a href="/wiki/1990s.html" title="1990s">1990s</a> the internal architecture moved towards being more of a <a href="/wiki/RISC.html" title="RISC">RISC</a> or <a href="/wiki/VLIW.html" title="VLIW">VLIW</a> design. Most modern x86 processors translate their instructions to one or more RISC-like "micro-ops" before they execute them, allowing the substeps of complex instructions to be executed in parallel in a <a href="/wiki/Superscalar.html" title="Superscalar">superscalar</a> fashion, rather than just being able to execute instructions in parallel as the original <a href="/wiki/Pentium.html" title="Pentium">Pentium</a> could do. This behaviour is, however, invisible to the assembly programmer.</p>
<p>The modern x86 instruction set is really a series of extensions of instruction sets that began with the Intel <a href="/wiki/8008.html" title="8008">8008</a> microprocessor. Nearly full binary backward compatibility is actually present between the Intel <a href="/wiki/8086.html" title="8086">8086</a> chip through to the modern <a href="/wiki/Pentium_4.html" title="Pentium 4">Pentium 4</a>, <a href="/wiki/Intel_Core.html" title="Intel Core">Intel Core</a>, <a href="/wiki/Athlon_64.html" title="Athlon 64">Athlon 64</a>, <a href="/wiki/Opteron.html" title="Opteron">Opteron</a>, etc. processors. (There are certain unusual exceptions, such as the counted shift instructions, corrections to the original PUSHA instruction, some orphaned Intel <a href="/wiki/80286.html" title="80286">80286</a> semantics, the dropped <a href="/wiki/LOADALL.html" title="LOADALL">LOADALL</a> instruction, and the Pentium 4 giving up on precise FPU operation counts.) Each successive instruction extension has been either simply directly added, or accompanied by adding execution modes to the processor.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: The various kinds of instructions">edit</a>]</div>
<p><a name="The_various_kinds_of_instructions" id="The_various_kinds_of_instructions"></a></p>
<h3>The various kinds of instructions</h3>
<p>In general, the features of the modern <a href="/wiki/X86_instruction_set.html" title="X86 instruction set">x86 instruction set</a> are:</p>
<ul>
<li>variable length and alignment independent (encoded as little endian, as is all data in the x86 architecture)</li>
<li>both general and implicit register usage. Although the registers are theoretically general purpose, there are very few of them and all but one (EBX) is affected by the operation of one or more instruction with no facility to protect them or use a different register. In this sense they are not truly general purpose.</li>
<li>double operand (that is to say, the first register may usually be used for both input and output)</li>
<li>supports various complex addressing modes (including immediate addressing, offset addressing, and scaled index addressing, but not PC-relative)</li>
<li>contains special support for atomic instructions (XCHG, CMPXCHG(8B), XADD, and integer instructions which combine with the LOCK prefix)</li>
<li>includes floating point (to a stack of registers) and integer instructions,</li>
<li>produces conditional flags implicitly (through most integer ALU instruction) and explicitly (via the CMP instruction)</li>
<li><a href="/wiki/SIMD.html" title="SIMD">SIMD</a> instructions (instructions which perform parallel simultaneous single instructions on many operands encoded in adjacent cells of wider registers).</li>
</ul>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: The stack">edit</a>]</div>
<p><a name="The_stack" id="The_stack"></a></p>
<h3>The stack</h3>
<p>The x86 processor also comes with a built-in execution stack mechanism. The CALL/RET and the INT/IRET instructions use the properly set up stack to save and restore call-return points.</p>
<p>However, unlike many other processor families such as Power and 68K, there is no hardware support for multiple stacks and so data and control-flow information must be combined into the same stack.</p>
<p>In order to alleviate this limitation, instructions like ENTER/LEAVE, or other direct manipulations of the stack register (ESP) can be used for saving local data in the stack. The instruction architecture also includes PUSH/POP instructions for direct usage of the stack for integer and address quantities. This helps simplify ABI specifications with respect to "call stack" software support mechanisms as compared with some RISC architectures which must be more explicit about call stack details.</p>
<p>The combination of a single hardware stack and the limited number of other registers available creates one of the most significent bottlenecks in x86 code.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Execution modes">edit</a>]</div>
<p><a name="Execution_modes" id="Execution_modes"></a></p>
<h3>Execution modes</h3>
<p>The processor supports numerous modes of operation in which some instructions are available and some are not. A 16-bit subset of instructions are available in "real mode" (available since the 8086), "16-bit protected mode" (available since the 80286), or "v86 mode" (available since the Intel <a href="/wiki/80386.html" title="80386">80386</a>). In "32-bit protected mode" (available in processors starting with the Intel 80386) or "legacy mode" (available when 64 bit extensions are enabled), 32-bit instructions (plus SIMD instructions) are available. In "long mode" (available since the AMD Opteron processor) 64-bit instructions are available.</p>
<p>The instruction set is based on similar ideas in each mode, but involves different ways of accessing memory and thus employs different programming strategies.</p>
<p>For information on the assembly language within a respective mode, see:</p>
<ul>
<li><a href="/wiki/X86_assembly_programming_in_real_mode.html" title="X86 assembly programming in real mode">Assembly in real mode</a></li>
<li><a href="/wiki/X86_assembly_programming_in_protected_mode.html" title="X86 assembly programming in protected mode">Assembly in protected mode</a></li>
<li><a href="/wiki/X86_assembly_programming_in_long_mode.html" title="X86 assembly programming in long mode">Assembly in long mode</a></li>
</ul>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Real mode">edit</a>]</div>
<p><a name="Real_mode" id="Real_mode"></a></p>
<h4>Real mode</h4>
<p>Real mode is mostly 16-bit, but since the 80386 it is possible to use 32-bit registers in this mode. It is also possible to enable partial 32-bit addressing in real mode through a bug/feature that appears under certain conditions when switching from protected mode back to real mode. Some <a href="/wiki/DOS_extender.html" title="DOS extender">DOS extenders</a> make use of this to make it possible to access more than 1 <a href="/wiki/Megabyte.html" title="Megabyte">megabyte</a> of <a href="/wiki/Random_Access_Memory.html" title="Random Access Memory">RAM</a>. This bug-mode is sometimes called <a href="/wiki/Unreal_mode.html" title="Unreal mode">unreal mode</a> by assembly programmers.</p>
<p>A memory reference specifies a 16-bit offset in a segment; the actual 20-bit address is given by SEGMENT * 16 + OFFSET, where SEGMENT is the contents of the segment register for the segment, and OFFSET is the offset within that segment. Segments are either implicit or made explicit via a segment override. By default the general registers are assumed to use the DS (data) segment, the stack registers are assumed to use the SS (stack) segment, and IP is assumed to use the CS (code) segment. This segmented architecture allowed for addressing just a little over 1MB of memory; however, only 64K could be addressed within a given segment at any one time. On earlier <a href="/wiki/IBM_PC_compatible.html" title="IBM PC compatible">IBM PC compatible</a> machines, this also caused great confusion with something called the "A20" line, since, while the addresses from 0x100000 to 0x10FFEF could technically be addressed, early systems generally did not make the extra 64K of memory available, instead dropping the top bit which ended up wrapping the address. However, later systems did not exhibit this behaviour, since the x86 evolved ways of addressing more than 1MB of memory.</p>
<p>In order to use more than 64K of memory, the segment registers must be used. This created great complications for C compiler implementors who introduced odd pointer modes such as "near", "far" and "huge" to leverage the implicit nature of segmented architecture to different degrees, with some pointers containing 16-bit offsets within implied segments and other pointers containing segment addresses and offsets within segments.</p>
<div class="boilerplate seealso">
<dl>
<dd><i>For more details on this topic, see <a href="/wiki/X86_assembly_programming_in_real_mode.html" title="X86 assembly programming in real mode">x86 assembly programming in real mode</a>.</i></dd>
</dl>
</div>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Protected mode">edit</a>]</div>
<p><a name="Protected_mode" id="Protected_mode"></a></p>
<h4>Protected mode</h4>
<p>In the 80286, 16-bit protected mode was added. It was used in early operating systems that needed <a href="/wiki/Memory_protection.html" title="Memory protection">memory protection</a>. When implemented in the <i>kernel</i> itself, the mode delivers 24-bit physical addressing, which gives a maximum capability of 16 <a href="/wiki/Megabyte.html" title="Megabyte">megabytes</a> of physical memory and up to 1 GB of virtual addressing. Some early <a href="/wiki/Unix.html" title="Unix">Unix</a> operating systems, <a href="/wiki/OS/2.html" title="OS/2">OS/2</a> 1.x and <a href="/wiki/Windows_3.x.html" title="Windows 3.x">Windows 3.x</a> used this mode. Today, 16-bit protected mode is still used for running legacy <i>applications</i>, eg. <a href="/wiki/DPMI.html" title="DPMI">DPMI</a> compatible <a href="/wiki/DOS_extender.html" title="DOS extender">DOS extender</a> programs (through <a href="/wiki/Virtual_DOS_machine.html" title="Virtual DOS machine">virtual DOS machines</a>) or Windows 3.x applications (through the <a href="/wiki/Windows_on_Windows.html" title="Windows on Windows">Windows on Windows</a> subsystem) and certain classes of <a href="/wiki/Device_driver.html" title="Device driver">device drivers</a> in OS/2 2.0 and later, all under control of a 32-bit kernel.</p>
<p>In protected mode, a segment register no longer contains the physical address of the beginning of a segment, but contain a "selector" that points to a system-level structure called a segment descriptor. A segment descriptor contains the physical address of the beginning of the segment, the length of the segment, and access permissions to that segment. The offset is checked against the length of the segment, with offsets referring to locations outside the segment causing an exception. Offsets referring to locations inside the segment are combined with the physical address of the beginning of the segment to get the physical address corresponding to that offset.</p>
<p>The instruction set in protected mode is perfectly backward compatible with the one used in real mode.</p>
<p>In this mode, the same techniques used to access more than 64K of memory in real mode are used; "far", or long, pointers contain segment selectors rather than segment addresses.</p>
<p>In the 80386, 32-bit protected mode was added. It enables full 32-bit addressing, <a href="/wiki/Paging.html" title="Paging">paging</a>, a few more registers, and some new instructions to handle the 32-bit addressing.</p>
<p>In 32-bit protected mode, with paging not enabled, the address in a segment descriptor is the physical address of the beginning of the segment, and the address calculated from the address of the beginning of a segment and the offset within that segment is a physical address. With paging enabled, the address in a segment descriptor is the "linear" address, in a 32-bit address space, of the beginning of the segment, and the address calculated from the address of the beginning of a segment and the offset within that segment is a linear address in that address space. Addresses in that address space are translated to physical addresses via a page table. Linear addresses are 32-bit addresses. By default, physical addresses are also 32-bit addresses; however, there exists a page extension mode called <a href="/wiki/Physical_Address_Extension.html" title="Physical Address Extension">Physical Address Extension</a> or PAE, first added in the Intel <a href="/wiki/Pentium_Pro.html" title="Pentium Pro">Pentium Pro</a>, which allows an additional 4 bits of physical addressing. This mode does not change the length of segment offsets or linear addresses; those are still only 32 bits.</p>
<p>In this mode, as offsets within segments are 32 bits, there was less need for explicit segmentation, and, as 48-bit segmented addresses (segment selectors plus offset within segment) were translated to 32-bit linear addresses, explicit segmentation didn't conveniently expand the address space available to a program. Therefore, C compiler vendors and operating system vendors rarely supported segmented addresses in 32-bit protected mode.</p>
<p>x86 processors that support protected mode boot into <a href="/wiki/Real_mode.html" title="Real mode">real mode</a> for backward compatibility with the older 8086 class of processors. Typically, the <a href="/wiki/Operating_system.html" title="Operating system">operating system</a> is responsible for switching to <a href="/wiki/Protected_mode.html" title="Protected mode">protected mode</a> if it so wishes.</p>
<div class="boilerplate seealso">
<dl>
<dd><i>For more details on this topic, see <a href="/wiki/X86_assembly_programming_in_protected_mode.html" title="X86 assembly programming in protected mode">x86 assembly programming in protected mode</a>.</i></dd>
</dl>
</div>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Long mode">edit</a>]</div>
<p><a name="Long_mode" id="Long_mode"></a></p>
<h4>Long mode</h4>
<p>Long mode, as implemented in the <a href="/wiki/AMD64.html" title="AMD64">AMD64</a> instruction set, is a mode that enables 64-bit addressing, 64-bit extensions of most registers and some new 64-bit registers as well. It is mostly an extension of the 32-bit instruction set, but unlike the 16 -&gt; 32 bit transition, many instructions were dropped in the 64 bit mode. This does not affect actual binary backward compatibility (which would execute legacy code in other modes that retain support for those instructions), but it changes the way assembler and compilers for new code have to work.</p>
<p>To switch to <a href="/wiki/Long_mode.html" title="Long mode">long mode</a>, the processor has to first switch from real mode to protected mode, and then to long mode. Toby Opferman has written an example of how to do this last year under a 32 bit Operating System. This example driver actually takes over control of the 32 bit system, gets into Long Mode and then executes a 64 bit raw binary supplied by a user mode application. The driver is then able to return back to protected mode and restore control back to the Operating System. The source code is available from his website <a  class="external free" title="http://www.opferman.net/Files/64drv.zip">http://www.opferman.net/Files/64drv.zip</a>.</p>
<div class="boilerplate seealso">
<dl>
<dd><i>For more details on this topic, see <a href="/wiki/X86_assembly_programming_in_long_mode.html" title="X86 assembly programming in long mode">x86 assembly programming in long mode</a>.</i></dd>
</dl>
</div>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Integer registers">edit</a>]</div>
<p><a name="Integer_registers" id="Integer_registers"></a></p>
<h3>Integer registers</h3>
<p>The x86 in real mode and 16-bit protected mode contains 6 general 16-bit registers (AX, BX, CX, DX, SI, DI), 2 special stack registers (BP and SP), one 16-bit flags register (<a href="/wiki/FLAGS_register_%28computing%29.html" title="FLAGS register (computing)">FLAGS</a>), and 4 segment registers (CS, SS, DS, ES). The first 4 of the general registers are split into top and bottom half 8-bit registers (AX = AH:AL, BX = BH:BL, CX = CH:CL, DX = DH:DL) which are independently usable in 8-bit instruction forms. The instruction pointer (IP) register exists, but is only used in an implicit manner (though its value can be stored on the stack and accessed without problem).</p>
<p>Starting with the Intel 80386 processor, the x86 in 32-bit protected mode extended the 16-bit registers to 32 bits (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP, EFLAGS, EIP). The older 16-bit registers were overlayed with the bottom half of the 32-bit registers and could be accessed with an instruction override. There is no "high-half" 16-bit register access; instead, Intel chose to generalize the addressing so that every register could be used for scaled index addressing, and so that EBP could be used as a general register, as well as a stack register.</p>
<p>Starting with the AMD Opteron processor, the x86 in 64-bit long mode (as a subset of <a href="/wiki/AMD64.html" title="AMD64">AMD64</a> or <a href="/wiki/X86-64.html" title="X86-64">x86-64</a> mode) extended the 32-bit registers in a similar way that 32-bit protected mode did before it (RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, RFLAGS, RIP). However, AMD also added 8 additional 64-bit general registers (R8, R9, ..., R15).</p>
<p>The addressing modes were not dramatically changed from 32-bit mode, except that addressing was extended to 64 bits, physical addressing is now sign extended (so memory always adds equally to the top and bottom of memory; note that this does not affect linear or virtual addressing), and other selector details have been dramatically reduced.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Floating point stack">edit</a>]</div>
<p><a name="Floating_point_stack" id="Floating_point_stack"></a></p>
<h3>Floating point stack</h3>
<p>Starting with the Intel 8087 floating point coprocessor (and first integrated as a standard extension of the x86 architecture in the Intel <a href="/wiki/80486DX.html" title="80486DX">80486DX</a> chip) the x86 processor includes an 8-entry 80-bit floating point stack with individually selectable entries (st(0), st(1), ..., st(7), where st(0) is always the top entry of the stack). Floating point instructions can push entries onto the stack, or pop the top entry off. As one of its two operands, a floating point instruction may select any stack entry, however the other must be st(0). The FXCH instruction also exists as a convenience, to allow the swapping of any pair of stack entries. A floating point stack entry is only valid if it has previously been pushed onto the stack. The floating point instructions read and write data to memory using integer addressing to floating point values that are 32-bit, 64-bit, 80-bit, or in fact integer values that are 32 or 64 bit. Implicit numeric format conversions are performed as necessary.</p>
<p>The x86 floating point instructions can operate in one of 3 possible execution modes with respect to operand size: 32-bit, 64-bit or 80-bit, as well as various rounding modes. For compatibility (with external non-x86 sources, such as data generated on a RISC processor, which will typically support only 64-bit mode) reasons, the size mode is usually set to 64-bit, and the rounding mode is set to (TBD). However, some C and Fortran compilers use the full 80-bit precision for maximum accuracy.</p>
<p>Note that the AMD64 did not add additional entries to the floating point stack, though the additional integer registers can be used for memory addressing.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: SIMD registers">edit</a>]</div>
<p><a name="SIMD_registers" id="SIMD_registers"></a></p>
<h3>SIMD registers</h3>
<p>Starting with the mid-90s, numerous SIMD instruction extensions have been introduced. We will break those down here by their marketing names.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: MMX">edit</a>]</div>
<p><a name="MMX" id="MMX"></a></p>
<h4>MMX</h4>
<p>The <a href="/wiki/MMX.html" title="MMX">MMX</a> instruction set, which first appeared in the <a href="/wiki/Pentium#P55C.2C_Tillamook.html" title="Pentium">Pentium MMX</a>, mapped 8 64-bit SIMD registers (MM0, MM1, ..., MM7) on top of the floating point stack, but did not adopt the stack-like semantics. The reason for this mapping was so that existing operating systems could still correctly save and restore the register state when multitasking without modifications. SIMD instructions can arbitrarily access any of its SIMD registers in any instruction. To avoid confusion with floating point instructions, these SIMD instructions must execute in blocks bracketed by the EMMS instruction. EMMS instructions implicitly clear the FP stack as a side effect, so any FP entries are clearly lost as a result of the instruction.</p>
<p>MMX instructions use the MMX registers as pairs of 32-bit integer values, or sets of 4 16-bit integer values, or sets of 8 8-bit integer values.</p>
<p>Note that the AMD64 architecture did not add additional MMX registers, though the additional integer registers can be used for memory addressing.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: 3DNow!">edit</a>]</div>
<p><a name="3DNow.21"></a></p>
<h4>3DNow!</h4>
<p>The <a href="/wiki/3DNow%21.html" title="3DNow!">3DNow!</a> instructions use the MMX registers as pairs of 32-bit floating point values. 3DNow! instructions must execute in blocks bracketed by the FEMMS instruction, which also clear the FP stack.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Streaming SIMD extensions">edit</a>]</div>
<p><a name="Streaming_SIMD_extensions" id="Streaming_SIMD_extensions"></a></p>
<h4>Streaming SIMD extensions</h4>
<p>Starting with the Intel <a href="/wiki/Pentium_III.html" title="Pentium III">Pentium III</a>, these instruction sets used 8 new 128-bit registers called SSE registers (XMM0, XMM1, ..., XMM7). SIMD instructions can arbitrarily access any of its SIMD registers in any instruction. Intel and followed by AMD added more SIMD instruction sets, but used these same registers until AMD introduced the AMD64 long mode execution mode. AMD64 simply extends the number of registers to 16 128-bit registers (XMM8, XMM9, ..., XMM15), and extends the instructions to be able to use any of these registers.</p>
<p>The format of these registers depends on the instructions using them. The original <a href="/wiki/SSE.html" title="SSE">SSE</a> instruction set uses them as 4 simultaneous 32-bit floating point values. <a href="/wiki/SSE2.html" title="SSE2">SSE2</a> allows usage of them as 2 simultaneous 64-bit floating point values, 4 simultaneous 32-bit integer values, 8 simultaneous 16-bit integer values, or 16 simultaneous 8-bit values.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Instruction overview">edit</a>]</div>
<p><a name="Instruction_overview" id="Instruction_overview"></a></p>
<h2>Instruction overview</h2>
<p>As a CISC processor, the x86 offers a large number of instructions of varying capabilities.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Integer ALU instructions">edit</a>]</div>
<p><a name="Integer_ALU_instructions" id="Integer_ALU_instructions"></a></p>
<h3>Integer ALU instructions</h3>
<p>x86 assembly has the standard mathematical operations, <tt>add</tt>, <tt>sub</tt>, <tt>mul</tt>, with <tt>idiv</tt>; the <a href="/wiki/Logical_operator.html" title="Logical operator">logical operators</a> <tt>and</tt>, <tt>or</tt>, <tt>xor</tt>, <tt>neg</tt>; <a href="/wiki/Bitshift.html" title="Bitshift">bitshift</a> arithmetic and logical, <tt>sal</tt>/<tt>sar</tt>, <tt>shl</tt>/<tt>shr</tt>; rotate with and without carry, <tt>rcl</tt>/<tt>rcr</tt>, <tt>rol</tt>/<tt>ror</tt>, a complement of BCD arithmetic instructions, <tt>aaa</tt>, <tt>aad</tt>, <tt>daa</tt> and others.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Floating point instructions">edit</a>]</div>
<p><a name="Floating_point_instructions" id="Floating_point_instructions"></a></p>
<h3>Floating point instructions</h3>
<p>x86 assembly language includes instructions for a stack-based floating point unit. They include addition, subtraction, negation, multiplication, division, remainder, square roots, integer truncation, fraction truncation, and scale by power of two. The operations also include conversion instructions which can load or store a value from memory in any of the following formats: Binary coded decimal, 32-bit integer, 64-bit integer, 32-bit floating point, 64-bit floating point or 80-bit floating point (upon loading, the value is converted to the currently used floating point mode). The x86 also includes a number of transcendental functions including sine, cosine, tangent, arctangent, exponentiation with the base 2 and logarithms to bases 2, 10, or <a href="/wiki/E_%28mathematical_constant%29.html" title="E (mathematical constant)">e</a>.</p>
<p>The stack register to stack register format of the instructions is usually <tt>F(OP) st, st(*)</tt> or <tt>F(OP) st(*), st</tt>. Where st is equivalent to st(0), and st(*) is one of the 8 stack registers (st(0), st(1), ..., st(7)) Like the integers, the first operand is both the first source operand and the destination operand. FSUBR and FDIVR should be singled out as first swapping the source operands before performing the subtraction or division. The addition, subtraction, multiplication, division, store and comparison instructions include instruction modes that will pop the top of the stack after their operation is complete. So for example <tt>FADDP st(1), st</tt> performs the calculation st(1) = st(1) + st(0), then removes st(0) from the top of stack, thus making what was the result in st(1) the top of the stack in st(0).</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: SIMD instructions">edit</a>]</div>
<p><a name="SIMD_instructions" id="SIMD_instructions"></a></p>
<h3>SIMD instructions</h3>
<p>Modern x86 CPUs contain SIMD instructions, which largely perform the same operation in parallel on many values encoded in a wide SIMD register. Various instruction technologies support different operations on different register sets, but taken as complete whole (from MMX to SSE3) they include general computations on integer or floating point arithmetic (addition, subtraction, multiplication, shift, minimization, maximization, comparison, division or square root). So for example, <tt>PADDW MM0, MM1</tt> performs 4 parallel 16-bit (indicated by the W) integer adds (indicated by the PADD) of mm0 values to mm1 and stores the result in mm0. SSE and SSE-2 also include floating point modes in which only the very first value of the registers is actually modified. Some other unusual instructions have been added including a sum of absolute differences (used for motion estimation in video processing, such as is done in MPEG) and a 16-bit multiply accumulation instruction (useful for software-based alpha-blending). <a href="/wiki/SSE3.html" title="SSE3">SSE3</a> and <a  class="new" title="3DNow! Extensions">3DNow! Extensions</a>, include addition and subtraction instructions for treating paired floating point values like complex numbers.</p>
<p>These instruction sets also include numerous fixed sub-word instructions for shuffling, inserting and extracting the values around within the registers. In addition there are instructions for moving data between the integer registers and SSE/MMX registers.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Data manipulation instructions">edit</a>]</div>
<p><a name="Data_manipulation_instructions" id="Data_manipulation_instructions"></a></p>
<h3>Data manipulation instructions</h3>
<p>The x86 processor also includes complex addressing modes for addressing memory with an immediate offset, a register, a register with an offset, a scaled register with or without an offset, and a register with an optional offset and another scaled register. So for example, one can encode <tt>mov eax, [Table + ebx + esi*4]</tt> as a single instruction which loads 32 bits of data from the address computed as (Table + ebx + esi * 4) offset from the DS selector, and stores it to the eax register. In general the x86 processor can load and use memory matched to the size of any register it is operating on. (The SIMD instructions also include half-load instructions.)</p>
<p>The x86 instruction set includes string load, store and move instructions (LODS, STOS, and MOVS) which perform each operation to a specified size (B for 8-bit byte, W for 16-bit word, D for 32-bit double word) then increments the implicit address register (SI for LODS, DI for STOS, and both for MOVS). For the load and store, the implicit target/source register is in the AL, AX or EAX register (depending on size.) The implicit segment used is DS, except for MOVS which uses ES for the store and DS for the load. In modern x86 processors, these complex instructions don't offer any performance advantage over more simply implemented separate load/store and address increment instructions.</p>
<p>The stack is implemented with an implicitly decrementing (push) and incrementing (pop) stack pointer. In 16-bit mode, this implicit stack pointer is addressed as SS:[SP], in 32-bit mode it's SS:[ESP], and in 64-bit mode it's [RSP]. The stack pointer actually points to the next value that will be stored, under the assumption that its size will match the operating mode of the processor (i.e., 16, 32, or 64 bits) to match the default width of the PUSH/POP/CALL/RET instructions. Also included are the instructions ENTER and LEAVE which reserve and remove data from the top of the stack while setting up a stack frame pointer in BP/EBP/RBP. However, direct setting, or addition and subtraction to the SP/ESP/RSP register is also supported, so the ENTER/LEAVE instructions are generally unnecessary. Other instructions for manipulating the stack include PUSHF/POPF for storing and retrieving the (E)FLAGS register. The PUSHA/POPA instructions will store and retrieve the entire integer register state to and from the stack.</p>
<p>Values for a SIMD load or store are assumed to be packed in adjacent positions for the SIMD register and will align them in sequential little-endian order. Some SSE load and store instructions require 16-byte alignment to function properly. The SIMD instruction sets also include "prefetch" instructions which perform the load but do not target any register, used for cache loading. The SSE instruction sets also include non-temporal store instructions which will perform stores straight to memory without performing a cache allocate if the destination is not already cached (otherwise it will behave like a regular store.)</p>
<p>Most generic integer and floating point (but no SIMD) instructions can use one parameter as a complex address as the second source parameter. Integer instructions can also accept one memory parameter as a destination operand.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Programming flow">edit</a>]</div>
<p><a name="Programming_flow" id="Programming_flow"></a></p>
<h3>Programming flow</h3>
<p>The x86 assembly has an unconditional jump operation, <code>jmp</code> which can take an immediate address, a register or an indirect address as a parameter. (Note that most RISC processors only support a link register or short immediate displacement for jumping.)</p>
<p>Also supported are several conditional jumps, including <code>je</code> (jump on equality), <code>jne</code> (jump on inequality), <code>jg</code> (jump on greater than, signed), <code>jl</code> (jump on less than, signed), <code>ja</code> (jump on above/greater than, unsigned), <code>jb</code> (jump on below/less than, unsigned). These conditional operations are based on the state of specific bits in the (E)FLAGS register. Many arithmetic and logic operations set, clear or complement these flags depending on their result. The comparison <code>cmp</code> (compare) and <code>test</code> instructions set the flags as if they had performed a subtraction or a bitwise AND operation, respectively, without altering the values of the operands. There are also instructions such as <code>clc</code> (clear carry flag) and <code>cmc</code> (complement carry flag) which work on the flags directly. Floating point comparisons are performed via FCOM or FICOM instructions which eventually have to be converted to integer flags.</p>
<p>Each jump operation has three different forms, depending on the size of the operand. A <i>short</i> jump uses an 8-bit signed operand, which is a relative offset from the current instruction. In real mode or 16-bit protected mode, a <i>near</i> jump uses a 16-bit or unsigned operand as an address relative to the current segment base; in 32-bit protected mode, a <i>near</i> jump is a 16-bit or 32-bit signed relative offset similar to a short jump. A <i>far</i> jump is one that uses the full segment base:offset value as an absolute address. There are also indirect and indexed forms of each of these.</p>
<p>In addition to the simple jump operations, there are the <code>call</code> (call a subroutine) and <code>ret</code> (return from subroutine) instructions. Before transferring control to the subroutine, <code>call</code> pushes the segment offset address of the instruction following the <code>call</code> onto the stack; <code>ret</code> pops this value off the stack, and jumps to it, effectively returning the flow of control to that part of the program. In the case of a <code>far call</code>, the segment base is pushed following the offset.</p>
<p>There are also two similar instructions, <code>int</code> (interrupt), which saves the current register values on the stack, then performs a <code>far call</code>, except that instead of an address, it uses an <i>interrupt vector</i>, an index into a table of interrupt handler addresses. The matching return from interrupt instruction is <code>iret</code>, which restores the register values after returning. <i>Soft Interrupts</i> of the type described above are used by some operating systems for system calls, and can also be used in debugging hard interrupt handlers. <i>Hard interrupts</i> are triggered by external hardware events.</p>
<p><br /></p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: See also">edit</a>]</div>
<p><a name="See_also" id="See_also"></a></p>
<h2>See also</h2>
<ul>
<li><a href="/wiki/X86.html" title="X86">x86</a></li>
<li><a href="/wiki/X86_instruction_listings.html" title="X86 instruction listings">x86 instruction listings</a></li>
<li><a href="/wiki/X86_assembly_programming_in_real_mode.html" title="X86 assembly programming in real mode">x86 assembly programming in real mode</a></li>
<li><a href="/wiki/X86_assembly_programming_in_protected_mode.html" title="X86 assembly programming in protected mode">x86 assembly programming in protected mode</a></li>
<li><a href="/wiki/X86_assembly_programming_in_long_mode.html" title="X86 assembly programming in long mode">x86 assembly programming in long mode</a></li>
<li><a  class="external text" title="http://home.comcast.net/~fbui/intel.html">8086/80186/80286/80386/80486 Instruction Set</a></li>
</ul>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: External links">edit</a>]</div>
<p><a name="External_links" id="External_links"></a></p>
<h2>External links</h2>
<ul>
<li><a  class="external text" title="ftp://download.intel.com/design/Pentium4/manuals/25366520.pdf">IA-32 Intel Architecture Software Developer's Manual, Volume 1: Basic Architecture</a> (PDF)</li>
<li><a  class="external text" title="ftp://download.intel.com/design/Pentium4/manuals/25366620.pdf">IA-32 Intel Architecture Software Developer's Manual, Volume 2A: Instruction Set Reference, A-M</a> (PDF)</li>
<li><a  class="external text" title="ftp://download.intel.com/design/Pentium4/manuals/25366720.pdf">IA-32 Intel Architecture Software Developer's Manual, Volume 2B: Instruction Set Reference, N-Z</a> (PDF)</li>
<li><a  class="external text" title="ftp://download.intel.com/design/Pentium4/manuals/25366820.pdf">IA-32 Intel Architecture Software Developer's Manual, Volume 3A: System Programming Guide</a> (PDF)</li>
<li><a  class="external text" title="ftp://download.intel.com/design/Pentium4/manuals/25366920.pdf">IA-32 Intel Architecture Software Developer's Manual, Volume 3B: System Programming Guide</a> (PDF)</li>
<li><a  class="external text" title="http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/24592.pdf">AMD64 Architecture Programmer's Manual Volume 1: Application Programming</a> (PDF)</li>
<li><a  class="external text" title="http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/24593.pdf">AMD64 Architecture Programmer's Manual Volume 2: System Programming</a> (PDF)</li>
<li><a  class="external text" title="http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/24594.pdf">AMD64 Architecture Programmer's Manual Volume 3: General-Purpose and System Instructions</a> (PDF)</li>
<li><a  class="external text" title="http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/26568.pdf">AMD64 Architecture Programmer's Manual Volume 4: 128-Bit Media Instructions</a> (PDF)</li>
<li><a  class="external text" title="http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/26569.pdf">AMD64 Architecture Programmer's Manual Volume 5: 64-Bit Media and x87 Floating-Point Instructions</a> (PDF)</li>
</ul>

<!-- 
Pre-expand include size: 3690 bytes
Post-expand include size: 2195 bytes
Template argument size: 502 bytes
Maximum: 2048000 bytes
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:214948-0!1!0!default!!en!2 and timestamp 20060910140652 -->
<div class="printfooter">
Retrieved from "<a </div>
			<div id="catlinks"><p class='catlinks'><a  title="Special:Categories">Categories</a>: <span dir='ltr'><a  title="Category:Cleanup from November 2005">Cleanup from November 2005</a></span> | <span dir='ltr'><a  title="Category:Articles to be merged">Articles to be merged</a></span> | <span dir='ltr'><a  title="Category:Assembly languages">Assembly languages</a></span> | <span dir='ltr'><a  title="Category:X86 architecture">X86 architecture</a></span></p></div>			<!-- end content -->
			<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<ul>
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/X86_assembly_language.html">Article</a></li>
				 <li id="ca-talk"><a >Discussion</a></li>
				 <li id="ca-edit"><a >Edit this page</a></li>
				 <li id="ca-history"><a >History</a></li>
		</ul>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a >Sign in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(/images/wiki-en.png);" href="/wiki/Main_Page.html" title="Main Page"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage"><a href="/wiki/Main_Page.html">Main Page</a></li>
				<li id="n-portal"><a >Community Portal</a></li>
				<li id="n-Featured-articles"><a >Featured articles</a></li>
				<li id="n-currentevents"><a >Current events</a></li>
				<li id="n-recentchanges"><a >Recent changes</a></li>
				<li id="n-randompage"><a >Random article</a></li>
				<li id="n-help"><a >Help</a></li>
				<li id="n-contact"><a >Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a >Donations</a></li>
			</ul>
		</div>
	</div>
		<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/wiki/Special:Search" id="searchform"><div>
				<input id="searchInput" name="search" type="text" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" value="Search" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a >What links here</a></li>
				<li id="t-recentchangeslinked"><a >Related changes</a></li>
<li id="t-upload"><a >Upload file</a></li>
<li id="t-specialpages"><a >Special pages</a></li>
				<li id="t-print"><a >Printable version</a></li>				<li id="t-permalink"><a >Permanent link</a></li><li id="t-cite"><a >Cite this article</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>In other languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-pl"><a >Polski</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a ><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="MediaWiki" /></a></div>
				<div id="f-copyrightico"><a ><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
				<li id="lastmod"> This page was last modified 22:28, 2 September 2006.</li>
				<li id="copyright">All text is available under the terms of the <a class='internal'  title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal'  title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the Wikimedia Foundation, Inc.<br /></li>
				<li id="privacy"><a  title="wikimedia:Privacy policy">Privacy policy</a></li>
				<li id="about"><a  title="Wikipedia:About">About Wikipedia</a></li>
				<li id="disclaimer"><a  title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
		
	
		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
</div>
<!-- Served by srv60 in 0.079 secs. --></body></html>
