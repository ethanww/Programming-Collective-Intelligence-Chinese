<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="keywords" content="Lambda calculus,1930s,1935,1965,1977,1984,Algorithm,Alonzo Church,Ambient calculus,American Journal of Mathematics,Anonymous recursion" />
<link rel="shortcut icon"  />
<link rel="search" type="application/opensearchdescription+xml"  />
<link rel="copyright"  />
		<title>Lambda calculus - Wikipedia, the free encyclopedia</title>
		<style type="text/css" media="screen,projection">/*<![CDATA[*/ @import "/skins-1.5/monobook/main.css?9"; /*]]>*/</style>
		<link rel="stylesheet" type="text/css" media="print"  />
		<!--[if lt IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE50Fixes.css";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE55Fixes.css";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/skins-1.5/monobook/IE60Fixes.css";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/skins-1.5/monobook/IE70Fixes.css?1";</style><![endif]-->
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
		
		<script type= "text/javascript">
			var skin = "monobook";
			var stylepath = "/skins-1.5";

			var wgArticlePath = "/wiki/$1";
			var wgScriptPath = "/w";
			var wgServer = "http://en.wikipedia.org";
                        
			var wgCanonicalNamespace = "";
			var wgNamespaceNumber = 0;
			var wgPageName = "Lambda_calculus";
			var wgTitle = "Lambda calculus";
			var wgArticleId = 18203;
			var wgIsArticle = true;
                        
			var wgUserName = null;
			var wgUserLanguage = "en";
			var wgContentLanguage = "en";
		</script>
		                
		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?1"><!-- wikibits js --></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js"><!-- site js --></script>
		<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Common.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=MediaWiki:Monobook.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=-&action=raw&gen=css&maxage=2678400";
/*]]>*/</style>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js"></script>
	</head>
<body  class="mediawiki ns-0 ltr">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><div style="text-align:right; font-size:80%">Your <b><a  class="extiw" title="wikimedia:Fundraising">continued donations</a></b> keep Wikipedia running!&nbsp;&nbsp;&nbsp;&nbsp;</div>
</div>		<h1 class="firstHeading">Lambda calculus</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub">(Redirected from <a  title="Lambda-calculus">Lambda-calculus</a>)</div>
									<div id="jump-to-nav">Jump to: <a >navigation</a>, <a >search</a></div>			<!-- start content -->
			<p>In <a href="/wiki/Mathematical_logic.html" title="Mathematical logic">mathematical logic</a> and <a href="/wiki/Computer_science.html" title="Computer science">computer science</a>, <b>lambda calculus</b>, also <b>λ-calculus</b>, is a <a href="/wiki/Formal_system.html" title="Formal system">formal system</a> designed to investigate <a href="/wiki/Function_%28mathematics%29.html" title="Function (mathematics)">function</a> definition, function application, and <a href="/wiki/Recursion.html" title="Recursion">recursion</a>. It was introduced by <a href="/wiki/Alonzo_Church.html" title="Alonzo Church">Alonzo Church</a> and <a href="/wiki/Stephen_Cole_Kleene.html" title="Stephen Cole Kleene">Stephen Cole Kleene</a> in the <a href="/wiki/1930s.html" title="1930s">1930s</a>; Church used lambda calculus in 1936 to give a negative answer to the <a href="/wiki/Entscheidungsproblem.html" title="Entscheidungsproblem">Entscheidungsproblem</a>. Lambda calculus can be used to define what a <a href="/wiki/Computable_function.html" title="Computable function">computable function</a> is. The question of whether two lambda calculus expressions are equivalent cannot be solved by a general algorithm, and this was the first question, even before the <a href="/wiki/Halting_problem.html" title="Halting problem">halting problem</a>, which <a href="/wiki/Decision_problem.html" title="Decision problem">undecidability</a> could be proved. Lambda calculus has greatly influenced <a href="/wiki/Functional_programming.html" title="Functional programming">functional programming languages</a>, such as <a href="/wiki/Lisp_programming_language.html" title="Lisp programming language">Lisp</a>, <a href="/wiki/ML_programming_language.html" title="ML programming language">ML</a> and <a href="/wiki/Haskell_programming_language.html" title="Haskell programming language">Haskell</a>.</p>
<p>Lambda calculus can be called the smallest universal programming language. It consists of a single transformation rule (variable substitution) and a single function definition scheme. Lambda calculus is universal in the sense that any computable function can be expressed and evaluated using this formalism. It is thus equivalent to the <a href="/wiki/Turing_machine.html" title="Turing machine">Turing machine</a> formalism. However, lambda calculus emphasizes the use of transformation rules, and does not care about the actual machine implementing them. It is an approach more related to software than to hardware.</p>
<p>This article deals with the "untyped lambda calculus" as originally conceived by Church. Since then, some <a href="/wiki/Typed_lambda_calculus.html" title="Typed lambda calculus">typed lambda calculi</a> have been developed.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a ><span class="tocnumber">1</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">2</span> <span class="toctext">Informal description</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">3</span> <span class="toctext">Formal definition</span></a>
<ul>
<li class="toclevel-2"><a ><span class="tocnumber">3.1</span> <span class="toctext">α-conversion</span></a></li>
<li class="toclevel-2"><a ><span class="tocnumber">3.2</span> <span class="toctext">β-reduction</span></a></li>
<li class="toclevel-2"><a ><span class="tocnumber">3.3</span> <span class="toctext">η-conversion</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a ><span class="tocnumber">4</span> <span class="toctext">Arithmetic in lambda calculus</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">5</span> <span class="toctext">Logic and predicates</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">6</span> <span class="toctext">Pairs</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">7</span> <span class="toctext">Recursion</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">8</span> <span class="toctext">Computable functions and lambda calculus</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">9</span> <span class="toctext">Undecidability of equivalence</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">10</span> <span class="toctext">Lambda calculus and programming languages</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">11</span> <span class="toctext">Concurrency and parallelism</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">12</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">13</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">14</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<p><script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script></p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: History">edit</a>]</div>
<p><a name="History" id="History"></a></p>
<h2>History</h2>
<p>Originally, Church had tried to construct a complete formal system for the foundations of mathematics; when the system turned out to be susceptible to the analog of <a href="/wiki/Russell%27s_paradox.html" title="Russell's paradox">Russell's paradox</a>, he separated out the lambda calculus and used it to study <a href="/wiki/Computability.html" title="Computability">computability</a>, culminating in his negative answer to the <a href="/wiki/Entscheidungsproblem.html" title="Entscheidungsproblem">Entscheidungsproblem</a>.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Informal description">edit</a>]</div>
<p><a name="Informal_description" id="Informal_description"></a></p>
<h2>Informal description</h2>
<p>In lambda calculus, every expression stands for a function with a single argument (argument::input of a <a href="/wiki/Function_%28computer_science%29.html" title="Function (computer science)">function</a>); the argument of the function is in turn a function with a single argument, and the value of the function is another function with a single argument. A function is anonymously defined by a lambda expression which expresses the function's action on its argument. For instance, the "add-two" function <i>f</i> such that <tt>&#160;<i>f</i>(<i>x</i>) = <i>x</i> + 2&#160;</tt> would be expressed in lambda calculus as <tt>&#160;λ <i>x</i>. <i>x</i> + 2&#160;</tt> (or equivalently as <tt>&#160;λ <i>y</i>. <i>y</i> + 2</tt>;&#160; the name of the formal argument is immaterial) and the number <tt><i>f</i>(3)</tt> would be written as <tt>&#160;(λ <i>x</i>. <i>x</i> + 2) 3</tt>.&#160; Function application is <a href="/wiki/Left_associative_operator.html" title="Left associative operator">left associative</a>: <tt>&#160;<i>f</i> <i>x</i> <i>y</i> = (<i>f</i> <i>x</i>) <i>y</i></tt>.&#160; Consider the function which takes a function as argument and applies it to the number <tt>3</tt>:<tt>&#160;λ <i>f</i>. <i>f</i> 3</tt>.&#160; This latter function could be applied to our earlier "add-two" function as follows: <tt>&#160;(λ <i>f</i>. <i>f</i> 3) (λ <i>x</i>. <i>x</i>+2)</tt>.&#160; The three expressions</p>
<dl>
<dd><tt>(λ <i>f</i>. <i>f</i> 3) (λ <i>x</i>. <i>x</i> + 2)&#160;&#160;&#160;</tt> and <tt>&#160;&#160;&#160;(λ <i>x</i>. <i>x</i> + 2) 3&#160;&#160;&#160;</tt> and <tt>&#160;&#160;&#160;3 + 2&#160;&#160;&#160;</tt></dd>
</dl>
<p>are equivalent. A function of two variables is expressed in lambda calculus as a function of one argument which returns a function of one argument (see <a href="/wiki/Currying.html" title="Currying">currying</a>). For instance, the function <tt>&#160;<i>f</i>(<i>x</i>, <i>y</i>) = <i>x</i> - <i>y</i>&#160;</tt> would be written as <tt>&#160;λ <i>x</i>. λ <i>y</i>. <i>x</i> - <i>y</i></tt>. A common convention is to abbreviate curried functions as, for instance, <tt>&#160;λ <i>x</i> <i>y</i>. <i>x</i> - <i>y</i></tt>.</p>
<p>The three expressions</p>
<dl>
<dd><tt>(λ <i>x</i> <i>y</i>. <i>x</i> - <i>y</i>) 7 2&#160;&#160;&#160;</tt> and <tt>&#160;&#160;&#160;(λ <i>y</i>. 7 - <i>y</i>) 2&#160;&#160;&#160;</tt> and <tt>&#160;&#160;&#160;7 - 2&#160;&#160;&#160;</tt></dd>
</dl>
<p>are equivalent. It is this equivalence of lambda expressions which in general can not be decided by an algorithm.</p>
<p>Not every lambda expression can be reduced to a definite value like the ones above; consider for instance</p>
<dl>
<dd><tt>(λ <i>x</i>. <i>x</i> <i>x</i>) (λ <i>x</i>. <i>x</i> <i>x</i>)</tt></dd>
</dl>
<p>or</p>
<dl>
<dd><tt>(λ <i>x</i>. <i>x</i> <i>x</i> <i>x</i>) (λ <i>x</i>. <i>x</i> <i>x</i> <i>x</i>)</tt></dd>
</dl>
<p>and try to visualize what happens as you start to apply the first function to its argument. <tt>&#160;(λ <i>x</i>. <i>x</i> <i>x</i>)&#160;</tt> is also known as the ω <a href="/wiki/Combinator.html" title="Combinator">combinator</a>; <tt>&#160;((λ <i>x</i>. <i>x</i> <i>x</i>) (λ <i>x</i>. <i>x</i> <i>x</i>))&#160;</tt> is known as Ω, <tt>&#160;((λ <i>x</i>. <i>x</i> <i>x</i> <i>x</i>) (λ <i>x</i>. <i>x</i> <i>x</i> <i>x</i>))&#160;</tt> as Ω<sub>2</sub>, etc.</p>
<p>While the lambda calculus itself does not contain symbols for integers or addition, these can be defined as abbreviations within the calculus and arithmetic can be expressed as we will see below.</p>
<p>Lambda calculus expressions may contain <i>free variables</i>, i.e. variables not bound by any <tt>λ</tt>. For example, the variable <tt>&#160;<i>y</i>&#160;</tt> is free in the expression <tt>&#160;(λ <i>x</i>. <i>y</i>)&#160;</tt>, representing a function which always produces the result <tt>&#160;<i>y</i>&#160;</tt>. Occasionally, this necessitates the renaming of formal arguments, for instance in order to reduce</p>
<dl>
<dd><tt>(λ <i>x</i> <i>y</i>. <i>y</i> <i>x</i>) (λ <i>x</i>. <i>y</i>) &#160;&#160; to &#160;&#160; λ <i>z</i>. <i>z</i> (λ <i>x</i>. <i>y</i>)</tt></dd>
</dl>
<p>If one only formalizes the notion of function application and does not allow lambda expressions, one obtains <a href="/wiki/Combinatory_logic.html" title="Combinatory logic">combinatory logic</a>.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Formal definition">edit</a>]</div>
<p><a name="Formal_definition" id="Formal_definition"></a></p>
<h2>Formal definition</h2>
<p>Formally, we start with a <a href="/wiki/Countable.html" title="Countable">countably infinite</a> <a href="/wiki/Set.html" title="Set">set</a> of identifiers, say <tt>{a, b, c, ..., x, y, z, x<sub>1</sub>, x<sub>2</sub>, ...}</tt>. The set of all lambda expressions can then be described by the following <a href="/wiki/Context-free_grammar.html" title="Context-free grammar">context-free grammar</a> in <a href="/wiki/Backus-Naur_form.html" title="Backus-Naur form">BNF</a>:</p>
<ol>
<li><tt>&lt;expr&gt;&#160;::= &lt;identifier&gt;</tt></li>
<li><tt>&lt;expr&gt;&#160;::= (λ &lt;identifier&gt;. &lt;expr&gt;)</tt></li>
<li><tt>&lt;expr&gt;&#160;::= (&lt;expr&gt; &lt;expr&gt;)</tt></li>
</ol>
<p>The first two rules generate functions, while the third describes the application of a function to an argument. Usually the parentheses for lambda abstraction (rule 2) and function application (rule 3) are omitted if there is no ambiguity under the assumptions that (1) function application is left-associative, and (2) a lambda binds to the entire expression following it. For example, the expression <tt>&#160;((λ <i>x</i>. (<i>x</i> <i>x</i>)) (λ <i>y</i>. <i>y</i>))&#160;</tt> can be simply written as <tt>&#160;(λ <i>x</i>. <i>x</i> <i>x</i>) λ <i>y</i>. <i>y</i></tt>.</p>
<p>Lambda expressions such as <tt>&#160;λ <i>x</i>. (<i>x</i> <i>y</i>)&#160;</tt> do not define functions because the occurrence of the variable <tt><i>y</i></tt> is <i>free</i>, i.e., it is not <i>bound</i> by any <tt>λ</tt> in the expression. The binding of occurrences of variables is (with <a href="/wiki/Mathematical_induction.html" title="Mathematical induction">induction</a> upon the structure of the lambda expression) defined by the following rules:</p>
<ol>
<li>In an expression of the form <tt>&#160;<i>V</i></tt>,&#160; where <tt><i>V</i></tt> is a variable, this <tt><i>V</i></tt> is the single free occurrence.</li>
<li>In an expression of the form <tt>&#160;λ <i>V</i>. <i>E</i></tt>,&#160; the free occurrences are the free occurrences in <tt><i>E</i></tt> except those of <tt><i>V</i></tt>. In this case the occurrences of <tt><i>V</i></tt> in <tt><i>E</i></tt> are said to be bound by the <tt>λ</tt> before <tt><i>V</i></tt>.</li>
<li>In an expression of the form <tt>&#160;(<i>E</i> <i>E′</i>)</tt>,&#160; the free occurrences are the free occurrences in <tt><i>E</i></tt> and <tt><i>E′</i></tt>.</li>
</ol>
<p>Over the set of lambda expressions an <a href="/wiki/Equivalence_relation.html" title="Equivalence relation">equivalence relation</a> (here denoted as <tt>==</tt>) is defined that captures the intuition that two expressions denote the same function. This equivalence relation is defined by the <i>α-conversion rule</i> and the <i>β-reduction rule</i>. Sometimes an alternate equivalence relation, obtained by adopting a third rule called <i>η-conversion</i>, is used.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: α-conversion">edit</a>]</div>
<p><a name=".CE.B1-conversion"></a></p>
<h3>α-conversion</h3>
<p>The alpha-conversion rule is intended to express the idea that the names of the bound variables are unimportant; for example that <tt>&#160;λ<i>x</i>.<i>x</i>&#160;</tt> and <tt>&#160;λ<i>y</i>.<i>y</i>&#160;</tt> are the same function. However, the rule is not as simple as it first appears. There are a number of restrictions on when one bound variable may be replaced with another. For example, if we replace <i>x</i> with <i>y</i> in λ<i>x</i>.λ<i>y</i>.<i>x</i>, we get λ<i>y</i>.λ<i>y</i>.<i>y</i>, which is not at all the same.</p>
<p>The alpha-conversion rule states that if <tt><i>V</i></tt> and <tt><i>W</i></tt> are variables, <tt><i>E</i></tt> is a lambda expression, and</p>
<p><tt><i>E</i>[<i>V</i>&#160;:= <i>W</i>]</tt></p>
<p>means the expression <tt><i>E</i></tt> with every free occurrence of <tt><i>V</i></tt> in <tt><i>E</i></tt> replaced with <tt><i>W</i></tt>, then</p>
<dl>
<dd><tt>λ <i>V</i>. <i>E</i>&#160;&#160;==&#160;&#160;λ <i>W</i>. <i>E</i>[<i>V</i>&#160;:= <i>W</i>]</tt></dd>
</dl>
<p>if <tt><i>W</i></tt> does not appear freely in <tt><i>E</i></tt> and <tt><i>W</i></tt> is not bound by a <tt>λ</tt> in <tt><i>E</i></tt> whenever it replaces a <tt><i>V</i></tt>. This rule tells us for example that <tt>&#160;λ&#160;<i>x</i>.&#160;(λ&#160;<i>x</i>.&#160;<i>x</i>)&#160;<i>x</i>&#160;</tt> is the same as <tt>&#160;λ&#160;<i>y</i>.&#160;(λ&#160;<i>x</i>.&#160;<i>x</i>)&#160;<i>y</i></tt>.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: β-reduction">edit</a>]</div>
<p><a name=".CE.B2-reduction"></a></p>
<h3>β-reduction</h3>
<p>The beta-reduction rule expresses the idea of function application. It states that</p>
<dl>
<dd><tt>((λ <i>V</i>. <i>E</i>) <i>E′</i>)&#160;&#160;==&#160;&#160;<i>E</i>[<i>V</i>&#160;:= <i>E′</i>]</tt></dd>
</dl>
<p>if all free occurrences in <tt><i>E′</i></tt> remain free in <tt><i>E</i>[<i>V</i>&#160;:= <i>E′</i>]</tt>.</p>
<p>The relation <tt>==</tt> is then defined as the smallest equivalence relation that satisfies these two rules.</p>
<p>A more operational definition of the equivalence relation can be given by applying the rules only from left to right. A lambda expression which does not allow any beta reduction, i.e., has no subexpression of the form <tt>((λ <i>V</i>. <i>E</i>) <i>E′</i>)</tt>, is called a <i>normal form</i>. Not every lambda expression is equivalent to a normal form, but if it is, then the normal form is unique <a href="/wiki/Up_to.html" title="Up to">up to</a> naming of the bound variables. Furthermore, there is an algorithm for computing normal forms: keep replacing the first (left-most) bound variable with its corresponding actual argument, until no further reduction is possible. This algorithm halts <a href="/wiki/If_and_only_if.html" title="If and only if">if and only if</a> the lambda expression has a normal form. The <a href="/wiki/Church-Rosser_theorem.html" title="Church-Rosser theorem">Church-Rosser theorem</a> then states that two expressions result in the same normal form up to renaming of the bound variables <a href="/wiki/If_and_only_if.html" title="If and only if">if and only if</a> they are equivalent.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: η-conversion">edit</a>]</div>
<p><a name=".CE.B7-conversion"></a></p>
<h3>η-conversion</h3>
<p>There is a third rule, eta-conversion, which may be added to these two to form a new equivalence relation. Eta-conversion expresses the idea of <a href="/wiki/Extensionality.html" title="Extensionality">extensionality</a>, which in this context is that two functions are the same <a href="/wiki/If_and_only_if.html" title="If and only if">if and only if</a> they give the same result for all arguments. Eta-conversion converts between <tt>&#160;λ <i>x</i>. <i>f</i> <i>x</i>&#160;</tt> and <tt>&#160;<i>f</i>&#160;</tt> whenever <tt><i>x</i></tt> does not appear free in <tt><i>f</i></tt>. This can be seen to be equivalent to extensionality as follows:</p>
<p>If <tt><i>f</i></tt> and <tt><i>g</i></tt> are extensionally equivalent, i.e. if <tt>&#160;<i>f</i> <i>a</i>==<i>g</i> <i>a</i>&#160;</tt> for all lambda expressions <tt><i>a</i></tt>, then in particular by taking <tt><i>a</i></tt> to be a variable <tt><i>x</i></tt> not appearing free in <tt><i>f</i></tt> nor <tt><i>g</i></tt> we have <tt>&#160;<i>f</i>&#160;<i>x</i>&#160;==&#160;<i>g</i>&#160;<i>x</i>&#160;</tt> and hence <tt>&#160;λ&#160;<i>x</i>.&#160;<i>f</i>&#160;<i>x</i>&#160;==&#160;λ&#160;<i>x</i>.&#160;<i>g</i>&#160;<i>x</i></tt>,&#160; and so by eta-conversion <tt>&#160;<i>f</i>&#160;==&#160;<i>g</i></tt>.&#160; So if we take eta-conversion to be valid, we find extensionality is valid.</p>
<p>Conversely if extensionality is taken to be valid, then since by beta-reduction for all <tt><i>y</i></tt> we have <tt>&#160;(λ&#160;<i>x</i>.&#160;<i>f</i>&#160;<i>x</i>)&#160;<i>y</i>&#160;==&#160;<i>f</i>&#160;<i>y</i></tt>,&#160; we have <tt>&#160;λ&#160;<i>x</i>.&#160;<i>f</i>&#160;<i>x</i>&#160;&#160;==&#160;&#160;<i>f</i></tt>;&#160; i.e., eta-conversion is found to be valid.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Arithmetic in lambda calculus">edit</a>]</div>
<p><a name="Arithmetic_in_lambda_calculus" id="Arithmetic_in_lambda_calculus"></a></p>
<h2>Arithmetic in lambda calculus</h2>
<p>There are several possible ways to define the <a href="/wiki/Natural_number.html" title="Natural number">natural numbers</a> in lambda calculus, but by far the most common are the <a href="/wiki/Church_numeral.html" title="Church numeral">Church numerals</a>, which can be defined as follows:</p>
<dl>
<dd><tt>0&#160;:= λ <i>f</i> <i>x</i>. <i>x</i></tt></dd>
<dd><tt>1&#160;:= λ <i>f</i> <i>x</i>. <i>f</i> <i>x</i></tt></dd>
<dd><tt>2&#160;:= λ <i>f</i> <i>x</i>. <i>f</i> (<i>f</i> <i>x</i>)</tt></dd>
<dd><tt>3&#160;:= λ <i>f</i> <i>x</i>. <i>f</i> (<i>f</i> (<i>f</i> <i>x</i>))</tt></dd>
</dl>
<p>and so on. Intuitively, the number <tt><i>n</i></tt> in lambda calculus is a function that takes a function <tt><i>f</i></tt> as argument and returns the <tt><i>n</i></tt>-th composition of <tt><i>f</i></tt>. That is to say, a Church numeral is a <a href="/wiki/Higher-order_function.html" title="Higher-order function">higher-order function</a> -- it takes a single-argument function <tt><i>f</i></tt>, and returns another single-argument function.</p>
<p>(Note that in Church's original lambda calculus, the formal parameter of a lambda expression was required to occur at least once in the function body, which made the above definition of 0 impossible.) Given this definition of the Church numerals, we can define a successor function, which takes a number <tt><i>n</i></tt> and returns <tt><i>n</i> + 1</tt>:</p>
<dl>
<dd><tt>SUCC&#160;:= λ <i>n</i> <i>f</i> <i>x</i>. <i>f</i> (<i>n</i> <i>f</i> <i>x</i>)</tt></dd>
</dl>
<p>Addition is defined as follows:</p>
<dl>
<dd><tt>PLUS&#160;:= λ <i>m</i> <i>n</i> <i>f</i> <i>x</i>. <i>m</i> <i>f</i> (<i>n</i> <i>f</i> <i>x</i>)</tt></dd>
</dl>
<p><tt>PLUS</tt> can be thought of as a function taking two natural numbers as arguments and returning a natural number; it is fun to verify that</p>
<dl>
<dd><tt>PLUS 2 3 &#160;&#160;</tt> and <tt>&#160;&#160; 5</tt></dd>
</dl>
<p>are equivalent lambda expressions. Multiplication can then be defined as</p>
<dl>
<dd><tt>MULT&#160;:= λ <i>m</i> <i>n</i>. <i>m</i> (PLUS <i>n</i>) 0</tt>,</dd>
</dl>
<p>the idea being that multiplying <i>m</i> and <i>n</i> is the same as <i>m</i> times adding <i>n</i> to zero. Alternatively</p>
<dl>
<dd><tt>MULT&#160;:= λ <i>m</i> <i>n</i> <i>f</i>. <i>m</i> (<i>n</i> <i>f</i>)</tt></dd>
</dl>
<p>The predecessor <tt>&#160;PRED <i>n</i> = <i>n</i> - 1&#160;</tt> of a positive integer <i>n</i> is more difficult:</p>
<dl>
<dd><tt>PRED&#160;:= λ <i>n</i> <i>f</i> <i>x</i>. <i>n</i> (λ <i>g</i> <i>h</i>. <i>h</i> (<i>g</i> <i>f</i>)) (λ <i>u</i>. <i>x</i>) (λ <i>u</i>. <i>u</i>)&#160;</tt></dd>
</dl>
<p>or alternatively</p>
<dl>
<dd><tt>PRED&#160;:= λ <i>n</i>. <i>n</i> (λ <i>g</i> <i>k</i>. (<i>g</i> 1) (λ <i>u</i>. PLUS (<i>g</i> <i>k</i>) 1) <i>k</i>) (λ <i>v</i>. 0) 0</tt></dd>
</dl>
<p>Note the trick <tt>(<i>g</i> 1) (λ <i>u</i>. PLUS (<i>g</i> <i>k</i>) 1) <i>k</i></tt> which evaluates to <tt><i>k</i></tt> if <tt><i>g</i>(1)</tt> is zero and to <tt><i>g</i>(<i>k</i>) + 1</tt> otherwise.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Logic and predicates">edit</a>]</div>
<p><a name="Logic_and_predicates" id="Logic_and_predicates"></a></p>
<h2>Logic and predicates</h2>
<p>By convention, the following two definitions (known as Church booleans) are used for the boolean values <tt>TRUE</tt> and <tt>FALSE</tt>:</p>
<dl>
<dd><tt>TRUE&#160;:= λ <i>x</i> <i>y</i>. <i>x</i></tt></dd>
<dd><tt>FALSE&#160;:= λ <i>x</i> <i>y</i>. <i>y</i></tt>
<dl>
<dd>(Note that <tt>FALSE</tt> is equivalent to the Church numeral zero defined above)</dd>
</dl>
</dd>
</dl>
<p>Then, with these two λ-terms, we can define some logic operators:</p>
<dl>
<dd><tt>AND&#160;:= λ <i>p</i> <i>q</i>. <i>p q</i> FALSE</tt></dd>
<dd><tt>OR&#160;:= λ <i>p</i> <i>q</i>. <i>p</i> TRUE <i>q</i></tt></dd>
<dd><tt>NOT&#160;:= λ <i>p</i>. <i>p</i> FALSE TRUE</tt></dd>
<dd><tt>IFTHENELSE&#160;:= λ <i>p</i> <i>x</i> <i>y</i>. <i>p x y</i></tt></dd>
</dl>
<p>We are now able to compute some logic functions, as for example:</p>
<dl>
<dd><tt>AND TRUE FALSE</tt>
<dl>
<dd><tt>≡ (λ <i>p</i> <i>q</i>. <i>p q</i> FALSE) TRUE FALSE →<sub>β</sub> TRUE FALSE FALSE</tt></dd>
<dd><tt>≡ (λ <i>x</i> <i>y</i>. <i>x</i>) FALSE FALSE →<sub>β</sub> FALSE</tt></dd>
</dl>
</dd>
</dl>
<p>and we see that <tt>AND TRUE FALSE</tt> is equivalent to <tt>FALSE</tt>.</p>
<p>A <i>predicate</i> is a function which returns a boolean value. The most fundamental predicate is <tt>ISZERO</tt> which returns <tt>TRUE</tt> if its argument is the Church numeral <tt>0</tt>, and <tt>FALSE</tt> if its argument is any other Church numeral:</p>
<dl>
<dd><tt>ISZERO&#160;:= λ <i>n</i>. <i>n</i> (λ <i>x</i>. FALSE) TRUE</tt></dd>
</dl>
<p>The availability of predicates and the above definition of <tt>TRUE</tt> and <tt>FALSE</tt> make it convenient to write "if-then-else" statements in lambda calculus.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Pairs">edit</a>]</div>
<p><a name="Pairs" id="Pairs"></a></p>
<h2>Pairs</h2>
<p>A pair (2-tuple) datatype can be defined in terms of <tt>TRUE</tt> and <tt>FALSE</tt>.</p>
<dl>
<dd><tt><a href="/wiki/Cons.html" title="Cons">CONS</a>&#160;:= λ<i>f</i>.λ<i>s</i>. λ<i>b</i>. <i>b</i> <i>f</i> <i>s</i></tt></dd>
<dd><tt><a href="/wiki/Car_and_cdr.html" title="Car and cdr">CAR</a>&#160;:= λ<i>p</i>. <i>p</i> TRUE</tt></dd>
<dd><tt><a href="/wiki/Car_and_cdr.html" title="Car and cdr">CDR</a>&#160;:= λ<i>p</i>. <i>p</i> FALSE</tt></dd>
</dl>
<p>A linked list datatype can be defined as either a reserved value (e.g. <tt>FALSE</tt>) for the empty list, or the <tt>CONS</tt> of an element and a smaller list.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Recursion">edit</a>]</div>
<p><a name="Recursion" id="Recursion"></a></p>
<h2>Recursion</h2>
<p><a href="/wiki/Recursion.html" title="Recursion">Recursion</a> is the definition of a function using the function itself; on the face of it, lambda calculus does not allow this. However, this impression is misleading. Consider for instance the <a href="/wiki/Factorial.html" title="Factorial">factorial</a> function <tt><i>f</i>(<i>n</i>)</tt> recursively defined by</p>
<dl>
<dd><tt><i>f</i>(<i>n</i>) = 1, if <i>n</i> = 0; and <i>n</i>·<i>f</i>(<i>n</i>-1), if <i>n</i>&gt;0</tt>.</dd>
</dl>
<p>In lambda calculus, one cannot define a function which includes itself. To get around this, one may start by defining a function, here called <tt><i>g</i></tt>, which takes a function <tt><i>f</i></tt> as an argument and returns another function that takes <tt><i>n</i></tt> as an argument:</p>
<dl>
<dd><tt><i>g</i>&#160;:= λ <i>f</i> <i>n</i>. (1, if <i>n</i> = 0; and <i>n</i>·<i>f</i>(<i>n</i>-1), if <i>n</i>&gt;0)</tt>.</dd>
</dl>
<p>The function that <tt><i>g</i></tt> returns is either the constant <tt>1</tt>, or <i>n</i> times the application of the function <tt><i>f</i></tt> to <tt><i>n</i>-1</tt>. Using the <tt>ISZERO</tt> predicate, and boolean and algebraic definitions described above, the function <tt><i>g</i></tt> can be defined in lambda calculus.</p>
<p>However, <tt><i>g</i></tt> by itself is still not recursive; in order to use <tt><i>g</i></tt> to create the recursive factorial function, the function passed to <tt><i>g</i></tt> as <tt><i>f</i></tt> must have specific properties. Namely, the function passed as <tt><i>f</i></tt> must expand to the function <tt><i>g</i></tt> called with one argument -- and that argument must be the function that was passed as <tt><i>f</i></tt> again!</p>
<p>In other words, <tt><i>f</i></tt> must expand to <tt><i>g</i>(<i>f</i>)</tt>. This call to <tt><i>g</i></tt> will then expand to the above factorial function and calculate down to another level of recursion. In that expansion the function <tt><i>f</i></tt> will appear again, and will again expand to <tt><i>g</i>(<i>f</i>)</tt> and continue the recursion. This kind of function, where <tt><i>f</i> = <i>g</i>(<i>f</i>)</tt>, is called a <i>fixed-point</i> of <tt><i>g</i></tt>, and it turns out that it can be implemented in the lambda calculus using what is known as the <i>paradoxical operator</i> or <i>fixed-point operator</i> and is represented as <tt><i>Y</i></tt> -- the <a href="/wiki/Fixed_point_combinator.html" title="Fixed point combinator">Y combinator</a>:</p>
<dl>
<dd><tt><i>Y</i> = λ <i>g</i>. (λ <i>x</i>. <i>g</i> (<i>x</i> <i>x</i>)) (λ <i>x</i>. <i>g</i> (<i>x</i> <i>x</i>))</tt></dd>
</dl>
<p>In the lambda calculus, <tt><i>Y g</i></tt> is a fixed-point of <tt><i>g</i></tt>, as it expands to <tt><i>g</i> (<i>Y</i> <i>g</i>)</tt>. Now, to complete our recursive call to the factorial function, we would simply call <tt>&#160;<i>g</i> (<i>Y</i> <i>g</i>) <i>n</i></tt>,&#160; where <i>n</i> is the number we are calculating the factorial of.</p>
<p>Given <i>n</i> = 5, for example, this expands to:</p>
<dl>
<dd><tt>(λ <i>n</i>.(1, if <i>n</i> = 0; and <i>n</i>·((<i>Y g</i>)(<i>n</i>-1)), if <i>n</i>&gt;0)) 5</tt></dd>
<dd><tt>1, if 5 = 0; and 5·(<i>g</i>(<i>Y g</i>)(5-1)), if 5&gt;0</tt></dd>
<dd><tt>5·(<i>g</i>(<i>Y g</i>) 4)</tt></dd>
<dd><tt>5·(λ <i>n</i>. (1, if <i>n</i> = 0; and <i>n</i>·((<i>Y g</i>)(<i>n</i>-1)), if <i>n</i>&gt;0) 4)</tt></dd>
<dd><tt>5·(1, if 4 = 0; and 4·(<i>g</i>(<i>Y g</i>)(4-1)), if 4&gt;0)</tt></dd>
<dd><tt>5·(4·(<i>g</i>(<i>Y g</i>) 3))</tt></dd>
<dd><tt>5·(4·(λ <i>n</i>. (1, if <i>n</i> = 0; and <i>n</i>·((<i>Y g</i>)(<i>n</i>-1)), if <i>n</i>&gt;0) 3))</tt></dd>
<dd><tt>5·(4·(1, if 3 = 0; and 3·(<i>g</i>(<i>Y g</i>)(3-1)), if 3&gt;0))</tt></dd>
<dd><tt>5·(4·(3·(<i>g</i>(<i>Y g</i>) 2)))</tt></dd>
<dd><tt>...</tt></dd>
</dl>
<p>And so on, evaluating the structure of the algorithm recursively. Every recursively defined function can be seen as a fixed point of some other suitable function, and therefore, using <tt><i>Y</i></tt>, every recursively defined function can be expressed as a lambda expression. In particular, we can now cleanly define the subtraction, multiplication and comparison predicate of natural numbers recursively.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Computable functions and lambda calculus">edit</a>]</div>
<p><a name="Computable_functions_and_lambda_calculus" id="Computable_functions_and_lambda_calculus"></a></p>
<h2>Computable functions and lambda calculus</h2>
<p>A function <tt><i>F</i>: <b>N</b> → <b>N</b></tt> of <a href="/wiki/Natural_number.html" title="Natural number">natural numbers</a> is a <a href="/wiki/Computable_function.html" title="Computable function">computable function</a> <a href="/wiki/If_and_only_if.html" title="If and only if">if and only if</a> there exists a lambda expression <tt><i>f</i></tt> such that for every pair of <i>x</i>, <i>y</i> in <tt><b>N</b></tt>, <tt>&#160;<i>F</i>(</tt><i>x</i><tt>)</tt> = <i>y</i>&#160; if and only if <tt>&#160;<i>f</i> <i>x</i>&#160;==&#160;<i>y</i></tt>,&#160; where <tt><i>x</i></tt> and <tt><i>y</i></tt> are the Church numerals corresponding to <i>x</i> and <i>y</i>, respectively. This is one of the many ways to define computability; see the <a href="/wiki/Church-Turing_thesis.html" title="Church-Turing thesis">Church-Turing thesis</a> for a discussion of other approaches and their equivalence.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Undecidability of equivalence">edit</a>]</div>
<p><a name="Undecidability_of_equivalence" id="Undecidability_of_equivalence"></a></p>
<h2>Undecidability of equivalence</h2>
<p>There is no algorithm which takes as input two lambda expressions and outputs <tt>TRUE</tt> or <tt>FALSE</tt> depending on whether or not the two expressions are equivalent. This was historically the first problem for which the unsolvability could be proven. Of course, in order to do so, the notion of <a href="/wiki/Algorithm.html" title="Algorithm">algorithm</a> has to be cleanly defined; Church used a definition via recursive functions, which is now known to be equivalent to all other reasonable definitions of the notion.</p>
<p>Church's proof first reduces the problem to determining whether a given lambda expression has a <i>normal form</i>. A normal form is an equivalent expression which cannot be reduced any further. Then he assumes that this predicate is computable, and can hence be expressed in lambda calculus. Building on earlier work by Kleene and constructing a <a href="/wiki/G%C3%B6del_numbering.html" title="Gödel numbering">Gödel numbering</a> for lambda expressions, he constructs a lambda expression <tt><i>e</i></tt> which closely follows the proof of <a href="/wiki/G%C3%B6del%27s_incompleteness_theorem.html" title="Gödel's incompleteness theorem">Gödel's first incompleteness theorem</a>. If <tt><i>e</i></tt> is applied to its own <a href="/wiki/G%C3%B6del_number.html" title="Gödel number">Gödel number</a>, a contradiction results.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Lambda calculus and programming languages">edit</a>]</div>
<p><a name="Lambda_calculus_and_programming_languages" id="Lambda_calculus_and_programming_languages"></a></p>
<h2>Lambda calculus and programming languages</h2>
<p>As pointed out by <a href="/wiki/Peter_Landin.html" title="Peter Landin">Peter Landin</a>'s 1965 classic <cite><a  class="external text" title="http://portal.acm.org/citation.cfm?id=363749&amp;coll=portal&amp;dl=ACM">A Correspondence between ALGOL 60 and Church's Lambda-notation</a></cite>, most <a href="/wiki/Programming_language.html" title="Programming language">programming languages</a> are rooted in the lambda calculus, which provides the basic mechanisms for procedural abstraction and procedure (subprogram) application.</p>
<p>Implementing the lambda calculus on a computer involves treating "functions" as <a href="/wiki/First-class_object.html" title="First-class object">first-class objects</a>, which raises implementation issues for stack-based programming languages. This is known as the <a href="/wiki/Funarg_problem.html" title="Funarg problem">Funarg problem</a>.</p>
<p>The most prominent counterparts to lambda calculus in programming are <a href="/wiki/Functional_programming_language.html" title="Functional programming language">functional programming languages</a>, which essentially implement the calculus augmented with some <a href="/wiki/Constant.html" title="Constant">constants</a> and <a href="/wiki/Datatype.html" title="Datatype">datatypes</a>. <a href="/wiki/Lisp_programming_language.html" title="Lisp programming language">Lisp</a> uses a variant of lambda notation for defining functions, but only its purely functional subset ("Pure Lisp") is really equivalent to lambda calculus.</p>
<p>Functional languages are not the only ones to support functions as <a href="/wiki/First-class_object.html" title="First-class object">first-class objects</a>. Numerous <a href="/wiki/Imperative_programming.html" title="Imperative programming">imperative languages</a>, e.g. <a href="/wiki/Pascal.html" title="Pascal">Pascal</a>, have long supported passing subprograms as arguments to other subprograms. In <a href="/wiki/C_programming_language.html" title="C programming language">C</a> and <a href="/wiki/C%2B%2B.html" title="C++">C++</a> the equivalent result is obtained by passing <cite>pointers</cite> to the code of functions (subprograms). Such mechanisms are limited to subprograms written explicitly in the code, and do not directly support higher-level functions. Some imperative <a href="/wiki/Object-oriented_language.html" title="Object-oriented language">object-oriented languages</a> have notations that represent functions of any order; such mechanisms are available in <a href="/wiki/Smalltalk.html" title="Smalltalk">Smalltalk</a> and more recently in <a href="/wiki/Eiffel_programming_language.html" title="Eiffel programming language">Eiffel</a> ("agents") and <a href="/wiki/C.html" title="C">C#</a> ("delegates"). As an example, the Eiffel "inline agent" expression</p>
<pre>
   <b>agent</b> (x: REAL): REAL <b>do Result</b> := x * x <b>end</b>
</pre>
<p>denotes an object corresponding to the lambda expression λ x . x*x (with call by value). It can be treated like any other expression, e.g. assigned to a variable or passed around to routines. If the value of <cite>square</cite> is the above agent expression, then the result of applying <cite>square</cite> to a value a (β-reduction) is expressed as <cite>square</cite>.item ([a]), where the argument is passed as a <a href="/wiki/Tuple.html" title="Tuple">tuple</a>.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Concurrency and parallelism">edit</a>]</div>
<p><a name="Concurrency_and_parallelism" id="Concurrency_and_parallelism"></a></p>
<h2>Concurrency and parallelism</h2>
<p>The Church-Rosser property of the lambda calculus means that evaluation (β-reduction) can be carried out in <i>any order</i>, even concurrently. (Indeed, the lambda calculus is <a href="/wiki/Referential_transparency.html" title="Referential transparency">referentially transparent</a>.) While this means the lambda calculus can model the various <a href="/wiki/Evaluation_strategy#Nondeterministic_strategies.html" title="Evaluation strategy">nondeterministic evaluation strategies</a>, it does not offer any richer notion of <a href="/wiki/Parallel_computing.html" title="Parallel computing">parallelism</a>, nor can it express any <a href="/wiki/Concurrent_programming_language.html" title="Concurrent programming language">concurrency</a> issues. <a href="/wiki/Process_calculus.html" title="Process calculus">Process calculi</a> such as <a href="/wiki/Communicating_sequential_processes.html" title="Communicating sequential processes">CSP</a>, the <a href="/wiki/Calculus_of_Communicating_Systems.html" title="Calculus of Communicating Systems">CCS</a>, the <a href="/wiki/Pi_calculus.html" title="Pi calculus">π calculus</a> and the <a href="/wiki/Ambient_calculus.html" title="Ambient calculus">ambient calculus</a> have been designed for such purposes.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: See also">edit</a>]</div>
<p><a name="See_also" id="See_also"></a></p>
<h2>See also</h2>
<ul>
<li><a href="/wiki/Anonymous_recursion.html" title="Anonymous recursion">Anonymous recursion</a></li>
<li><a href="/wiki/Curry-Howard_isomorphism.html" title="Curry-Howard isomorphism">Curry-Howard isomorphism</a></li>
<li><a href="/wiki/Knights_of_the_Lambda_Calculus.html" title="Knights of the Lambda Calculus">Knights of the Lambda Calculus</a></li>
<li><a href="/wiki/Lambda_cube.html" title="Lambda cube">Lambda cube</a></li>
<li><a href="/wiki/Rewriting.html" title="Rewriting">Rewriting</a></li>
<li><a href="/wiki/SKI_combinator_calculus.html" title="SKI combinator calculus">SKI combinator calculus</a></li>
<li><a href="/wiki/System_F.html" title="System F">System F</a></li>
<li><a  class="new" title="Thierry Coquand">Thierry Coquand</a>'s <a href="/wiki/Calculus_of_constructions.html" title="Calculus of constructions">calculus of constructions</a></li>
<li><a href="/wiki/Typed_lambda_calculus.html" title="Typed lambda calculus">Typed lambda calculus</a></li>
<li><a href="/wiki/Unlambda.html" title="Unlambda">Unlambda</a></li>
</ul>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: References">edit</a>]</div>
<p><a name="References" id="References"></a></p>
<h2>References</h2>
<ul>
<li>Abelson, Harold &amp; Gerald Jay Sussman. <a href="/wiki/Structure_and_Interpretation_of_Computer_Programs.html" title="Structure and Interpretation of Computer Programs">Structure and Interpretation of Computer Programs</a>. <a href="/wiki/The_MIT_Press.html" title="The MIT Press">The MIT Press</a>. <a  class="internal">ISBN 0-262-51087-1</a>.</li>
<li>Barendregt, Henk, <a  class="external text" title="http://www.elsevier.com/wps/find/bookdescription.cws_home/501727/description#description"><i>The lambda calculus, its syntax and semantics</i></a>, <a href="/wiki/North-Holland.html" title="North-Holland">North-Holland</a> (<a href="/wiki/1984.html" title="1984">1984</a>), is <i>the</i> comprehensive reference on the (untyped) lambda calculus; see also the paper <a  class="external text" title="http://citeseer.ist.psu.edu/barendregt94introduction.html"><i>Introduction to Lambda Calculus</i></a>.</li>
<li>Barendregt, Henk, <i>The Type Free Lambda Calculus</i> pp1091-1132 of <i>Handbook of Mathematical Logic</i>, <a href="/wiki/North-Holland.html" title="North-Holland">North-Holland</a> (<a href="/wiki/1977.html" title="1977">1977</a>) <a  class="internal">ISBN 0-7204-2285-X</a></li>
<li>Church, Alonzo, <i>An unsolvable problem of elementary number theory</i>, <a href="/wiki/American_Journal_of_Mathematics.html" title="American Journal of Mathematics">American Journal of Mathematics</a>, 58 (1936), pp. 345–363. This paper contains the proof that the equivalence of lambda expressions is in general not decidable.</li>
<li>Punit,Gupta, Amit &amp; Ashutosh Agte, <i>Untyped lambda-calculus, alpha-, beta- and eta- reductions and recursion</i></li>
<li>Henz, Martin, <i>The Lambda Calculus</i>. Formally correct development of the Lambda calculus.</li>
<li>Kleene, Stephen, <i>A theory of positive integers in formal logic</i>, <a href="/wiki/American_Journal_of_Mathematics.html" title="American Journal of Mathematics">American Journal of Mathematics</a>, 57 (<a href="/wiki/1935.html" title="1935">1935</a>), pp. 153–173 and 219–244. Contains the lambda calculus definitions of several familiar functions.</li>
<li><a href="/wiki/Peter_Landin.html" title="Peter Landin">Landin, Peter</a>, <i>A Correspondence Between ALGOL 60 and Church's Lambda-Notation</i>, <a href="/wiki/Communications_of_the_ACM.html" title="Communications of the ACM">Communications of the ACM</a>, vol. 8, no. 2 (<a href="/wiki/1965.html" title="1965">1965</a>), pages 89-101. Available from the <a  class="external text" title="http://portal.acm.org/citation.cfm?id=363749&amp;coll=portal&amp;dl=ACM">ACM site</a>. A classic paper highlighting the importance of lambda-calculus as a basis for programming languages.</li>
<li>Larson, Jim, <a  class="external text" title="http://www.jetcafe.org/~jim/lambda.html"><i>An Introduction to Lambda Calculus and Scheme</i></a>. A gentle introduction for programmers.</li>
</ul>
<p><i>Some parts of this article are based on material from <a href="/wiki/Free_On-line_Dictionary_of_Computing.html" title="Free On-line Dictionary of Computing">FOLDOC</a>, used with <a  title="Wikipedia:Foldoc license">permission</a>.</i></p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: External links">edit</a>]</div>
<p><a name="External_links" id="External_links"></a></p>
<h2>External links</h2>
<ul>
<li>L. Allison, <i><a  class="external text" title="http://www.csse.monash.edu.au/~lloyd/tildeFP/Lambda/Examples/">Some executable λ-calculus examples</a></i></li>
<li>Georg P. Loczewski, <a  class="external text" title="http://www.lambda-bound.com/book/lambdacalc/lcalconl.html"><i>The Lambda Calculus and A++</i></a></li>
<li>Raùl Rojas, <i><a  class="external text" title="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf">A Tutorial Introduction to the Lambda Calculus</a></i> -(<a href="/wiki/Portable_Document_Format.html" title="Portable Document Format">PDF</a>)</li>
<li>Chris Barker, <i><a  class="external text" title="http://ling.ucsd.edu/~barker/Lambda/">Lambda tutorial</a></i></li>
<li>David C. Keenan, <i><a  class="external text" title="http://users.bigpond.net.au/d.keenan/Lambda/">To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Animated Reduction</a></i></li>
</ul>


<!-- Saved in parser cache with key enwiki:pcache:idhash:18203-0!1!0!default!!en!2 and timestamp 20060909003814 -->
<div class="printfooter">
Retrieved from "<a </div>
			<div id="catlinks"><p class='catlinks'><a  title="Special:Categories">Categories</a>: <span dir='ltr'><a  title="Category:Mathematical logic">Mathematical logic</a></span> | <span dir='ltr'><a  title="Category:Computational models">Computational models</a></span> | <span dir='ltr'><a  title="Category:Logic in computer science">Logic in computer science</a></span> | <span dir='ltr'><a  title="Category:Lambda calculus">Lambda calculus</a></span> | <span dir='ltr'><a  title="Category:Theoretical computer science">Theoretical computer science</a></span> | <span dir='ltr'><a  title="Category:Formal methods">Formal methods</a></span> | <span dir='ltr'><a  title="Category:Recursion theory">Recursion theory</a></span></p></div>			<!-- end content -->
			<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<ul>
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Lambda_calculus.html">Article</a></li>
				 <li id="ca-talk"><a >Discussion</a></li>
				 <li id="ca-edit"><a >Edit this page</a></li>
				 <li id="ca-history"><a >History</a></li>
		</ul>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a >Sign in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(/images/wiki-en.png);" href="/wiki/Main_Page.html" title="Main Page"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage"><a href="/wiki/Main_Page.html">Main Page</a></li>
				<li id="n-portal"><a >Community Portal</a></li>
				<li id="n-Featured-articles"><a >Featured articles</a></li>
				<li id="n-currentevents"><a >Current events</a></li>
				<li id="n-recentchanges"><a >Recent changes</a></li>
				<li id="n-randompage"><a >Random article</a></li>
				<li id="n-help"><a >Help</a></li>
				<li id="n-contact"><a >Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a >Donations</a></li>
			</ul>
		</div>
	</div>
		<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/wiki/Special:Search" id="searchform"><div>
				<input id="searchInput" name="search" type="text" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" value="Search" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a >What links here</a></li>
				<li id="t-recentchangeslinked"><a >Related changes</a></li>
<li id="t-upload"><a >Upload file</a></li>
<li id="t-specialpages"><a >Special pages</a></li>
				<li id="t-print"><a >Printable version</a></li>				<li id="t-permalink"><a >Permanent link</a></li><li id="t-cite"><a >Cite this article</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>In other languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-ca"><a >Català</a></li>
				<li class="interwiki-cs"><a >Česky</a></li>
				<li class="interwiki-de"><a >Deutsch</a></li>
				<li class="interwiki-es"><a >Español</a></li>
				<li class="interwiki-eo"><a >Esperanto</a></li>
				<li class="interwiki-fr"><a >Français</a></li>
				<li class="interwiki-it"><a >Italiano</a></li>
				<li class="interwiki-he"><a >עברית</a></li>
				<li class="interwiki-hu"><a >Magyar</a></li>
				<li class="interwiki-nl"><a >Nederlands</a></li>
				<li class="interwiki-ja"><a >日本語</a></li>
				<li class="interwiki-pl"><a >Polski</a></li>
				<li class="interwiki-pt"><a >Português</a></li>
				<li class="interwiki-ru"><a >Русский</a></li>
				<li class="interwiki-sk"><a >Slovenčina</a></li>
				<li class="interwiki-sv"><a >Svenska</a></li>
				<li class="interwiki-zh"><a >中文</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a ><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="MediaWiki" /></a></div>
				<div id="f-copyrightico"><a ><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
				<li id="lastmod"> This page was last modified 00:34, 9 September 2006.</li>
				<li id="copyright">All text is available under the terms of the <a class='internal'  title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal'  title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the Wikimedia Foundation, Inc.<br /></li>
				<li id="privacy"><a  title="wikimedia:Privacy policy">Privacy policy</a></li>
				<li id="about"><a  title="Wikipedia:About">About Wikipedia</a></li>
				<li id="disclaimer"><a  title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
		
	
		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
</div>
<!-- Served by srv61 in 0.076 secs. --></body></html>
