<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="keywords" content="Reduced instruction set computer,AMD,AMD 29000,ARM Ltd,ARM architecture,AS/400,Acorn Archimedes,Addressing mode,AltiVec,Andrew S. Tanenbaum,Apple Computer" />
<link rel="shortcut icon"  />
<link rel="search" type="application/opensearchdescription+xml"  />
<link rel="copyright"  />
		<title>Reduced instruction set computer - Wikipedia, the free encyclopedia</title>
		<style type="text/css" media="screen,projection">/*<![CDATA[*/ @import "/skins-1.5/monobook/main.css?9"; /*]]>*/</style>
		<link rel="stylesheet" type="text/css" media="print"  />
		<!--[if lt IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE50Fixes.css";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE55Fixes.css";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/skins-1.5/monobook/IE60Fixes.css";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/skins-1.5/monobook/IE70Fixes.css?1";</style><![endif]-->
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
		
		<script type= "text/javascript">
			var skin = "monobook";
			var stylepath = "/skins-1.5";

			var wgArticlePath = "/wiki/$1";
			var wgScriptPath = "/w";
			var wgServer = "http://en.wikipedia.org";
                        
			var wgCanonicalNamespace = "";
			var wgNamespaceNumber = 0;
			var wgPageName = "Reduced_instruction_set_computer";
			var wgTitle = "Reduced instruction set computer";
			var wgArticleId = 26201;
			var wgIsArticle = true;
                        
			var wgUserName = null;
			var wgUserLanguage = "en";
			var wgContentLanguage = "en";
		</script>
		                
		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?1"><!-- wikibits js --></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js"><!-- site js --></script>
		<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Common.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=MediaWiki:Monobook.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=-&action=raw&gen=css&maxage=2678400";
/*]]>*/</style>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js"></script>
	</head>
<body  class="mediawiki ns-0 ltr">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><div style="text-align:right; font-size:80%">Your <b><a  class="extiw" title="wikimedia:Fundraising">continued donations</a></b> keep Wikipedia running!&nbsp;&nbsp;&nbsp;&nbsp;</div>
</div>		<h1 class="firstHeading">Reduced instruction set computer</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub">(Redirected from <a  title="RISC processor">RISC processor</a>)</div>
									<div id="jump-to-nav">Jump to: <a >navigation</a>, <a >search</a></div>			<!-- start content -->
			<dl>
<dd><i>This article is about computer architecture; for use of the acronym RISC in biology, see <a href="/wiki/RNA-induced_silencing_complex.html" title="RNA-induced silencing complex">RNA-induced silencing complex</a>.</i></dd>
</dl>
<p>The <b>reduced instruction set computer</b>, or <b>RISC</b>, is a <a href="/wiki/Microprocessor.html" title="Microprocessor">microprocessor</a> <a href="/wiki/CPU_design.html" title="CPU design">CPU design</a> philosophy that favors a simpler set of <a href="/wiki/Instruction_%28computer_science%29.html" title="Instruction (computer science)">instructions</a> that all take about the same amount of time to execute. The most common RISC microprocessors are <a href="/wiki/Atmel_AVR.html" title="Atmel AVR">AVR</a>, <a href="/wiki/PIC_microcontroller.html" title="PIC microcontroller">PIC</a>, <a href="/wiki/ARM_architecture.html" title="ARM architecture">ARM</a>, <a href="/wiki/DEC_Alpha.html" title="DEC Alpha">DEC Alpha</a>, <a href="/wiki/PA-RISC.html" title="PA-RISC">PA-RISC</a>, <a href="/wiki/SPARC.html" title="SPARC">SPARC</a>, <a href="/wiki/MIPS_architecture.html" title="MIPS architecture">MIPS</a>, and <a href="/wiki/Power_Architecture.html" title="Power Architecture">Power Architecture</a>.</p>
<p>The idea was originally inspired by the discovery that many of the features that were included in traditional <a href="/wiki/Central_processing_unit.html" title="Central processing unit">CPU</a> designs to facilitate coding were being ignored by the <a href="/wiki/Computer_program.html" title="Computer program">programs</a> that were running on them. Also these more complex features took several processor cycles to be performed. Additionally, the performance gap between the processor and main memory was increasing. This led to a number of techniques to streamline processing within the CPU, while at the same time attempting to reduce the total number of memory accesses.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a ><span class="tocnumber">1</span> <span class="toctext">Pre-RISC design philosophy</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">2</span> <span class="toctext">RISC design philosophy</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">3</span> <span class="toctext">Meanwhile...</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">4</span> <span class="toctext">Early RISC</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">5</span> <span class="toctext">Later RISC</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">6</span> <span class="toctext">Alternative term</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">7</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">8</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<p><script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script></p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Pre-RISC design philosophy">edit</a>]</div>
<p><a name="Pre-RISC_design_philosophy" id="Pre-RISC_design_philosophy"></a></p>
<h2>Pre-RISC design philosophy</h2>
<div class="boilerplate seealso">
<dl>
<dd><i>For more details on this topic, see <a href="/wiki/CPU_design.html" title="CPU design">CPU design</a>.</i></dd>
</dl>
</div>
<p><br />
In the <b>early days of the computer</b> industry, <a href="/wiki/Compiler.html" title="Compiler">compiler</a> technology did not exist at all. Programming was done in either <a href="/wiki/Machine_code.html" title="Machine code">machine code</a> or <a href="/wiki/Assembly_language.html" title="Assembly language">assembly language</a>. To make programming easier, computer architects created more and more complex instructions which were direct representations of high level functions of high level programming languages. The attitude at the time was that hardware design was easier than compiler design, so the complexity went into the hardware.</p>
<p>Another force that encouraged complexity was the lack of large memories. Since memories were small, it was advantageous for the density of information held in computer programs to be very high. When every <a href="/wiki/Byte.html" title="Byte">byte</a> of memory was precious, for example one's entire system only had a few kilobytes of storage, it moved the industry to such features as highly encoded instructions, instructions which could be variable sized, instructions which did multiple operations and instructions which did both data movement and data calculation. At that time, such instruction packing issues were of higher priority than the ease of decoding such instructions.</p>
<p>Memory was not only small, but rather slow since they were implemented using magnetic technology at the time. That was another reason to keep the density of information very high. By having dense information packing, one could decrease the frequency with which one had to access this slow resource.</p>
<p>CPUs had few registers for two reasons:</p>
<ul>
<li>bits in internal CPU registers are always more expensive than bits in external memory. The available level of silicon integration of the day meant large register sets would have been burdensome to the chip area or board areas available.</li>
<li>Having a large number of registers would have required a large number of instruction bits (using precious RAM) to be used as register specifiers.</li>
</ul>
<p>For the above reasons, CPU designers tried to make instructions that would do as much work as possible. This led to one instruction that would do all of the work in a single instruction: load up the two numbers to be added, add them, and then store the result back directly to memory. Another version would read the two numbers from memory, but store the result in a register. Another version would read one from memory and the other from a register and store to memory again. And so on. This processor design philosophy eventually became known as <a href="/wiki/Complex_Instruction_Set_Computer.html" title="Complex Instruction Set Computer">Complex Instruction Set Computer</a> (CISC).</p>
<p>The general goal at the time was to provide every possible <a href="/wiki/Addressing_mode.html" title="Addressing mode">addressing mode</a> for every instruction, a principle known as "orthogonality." This led to some complexity on the CPU, but in theory each possible command could be tuned individually, making the design faster than if the programmer used simpler commands.</p>
<p>The ultimate expression of this sort of design can be seen at two ends of the power spectrum, the <a href="/wiki/MOS_Technology_6502.html" title="MOS Technology 6502">6502</a> at one end, and the <a href="/wiki/VAX.html" title="VAX">VAX</a> at the other. The $25 single-chip 1 MHz 6502 had only a single general-purpose register, but its simplistic single-cycle memory interface allowed byte-wide operations to perform almost on par with significantly higher clocked designs, such as a 4 MHz <a href="/wiki/Zilog_Z80.html" title="Zilog Z80">Zilog Z80</a> using equally slow memory chips (i.e. approx. 300ns). The VAX was a <a href="/wiki/Minicomputer.html" title="Minicomputer">minicomputer</a> whose initial implementation required 3 racks of equipment for a single cpu, and was notable for the amazing variety of <a href="/wiki/Addressing_mode.html" title="Addressing mode">memory access</a> styles it supported, and the fact that every one of them was available for every instruction.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: RISC design philosophy">edit</a>]</div>
<p><a name="RISC_design_philosophy" id="RISC_design_philosophy"></a></p>
<h2>RISC design philosophy</h2>
<p>In the late 1970s researchers at <a href="/wiki/IBM.html" title="IBM">IBM</a> (and similar projects elsewhere) demonstrated that the majority of these "orthogonal" <a href="/wiki/Addressing_mode.html" title="Addressing mode">addressing modes</a> were ignored by most programs. This was a side effect of the increasing use of <a href="/wiki/Compiler.html" title="Compiler">compilers</a> to generate the programs, as opposed to writing them in <a href="/wiki/Assembly_language.html" title="Assembly language">assembly language</a>. The compilers in use at the time only had a limited ability to take advantage of the features provided by <a href="/wiki/Complex_instruction_set_computer.html" title="Complex instruction set computer">CISC</a> CPUs; this was largely a result of the difficulty of writing a compiler. The market was clearly moving to even wider use of compilers, diluting the usefulness of these orthogonal modes even more.</p>
<p>Another discovery was that since these operations were rarely used, in fact they tended to be <i>slower</i> than a number of smaller operations doing the same thing. This seeming <a href="/wiki/Paradox.html" title="Paradox">paradox</a> was a side effect of the time spent designing the CPUs, designers simply did not have time to tune every possible instruction, and instead tuned only the most used ones. One famous example of this was the <a href="/wiki/Vax.html" title="Vax">VAX</a>'s <code>INDEX</code> instruction, which ran slower than a loop implementing the same code.</p>
<p>At about the same time CPUs started to run even faster than the memory they talked to. Even in the late 1970s it was apparent that this disparity was going to continue to grow for at least the next decade, by which time the CPU would be tens to hundreds of times faster than the memory. It became apparent that more <a href="/wiki/Processor_register.html" title="Processor register">registers</a> (and later <a href="/wiki/Cache.html" title="Cache">caches</a>) would be needed to support these higher operating frequencies. These additional registers and cache memories would require sizeable chip or board areas that could be made available if the complexity of the CPU was reduced.</p>
<p>Yet another part of RISC design came from practical measurements on real-world programs. <a href="/wiki/Andrew_S._Tanenbaum.html" title="Andrew S. Tanenbaum">Andrew Tanenbaum</a> summed up many of these, demonstrating that most processors were vastly overdesigned. For instance, he showed that 98% of all the constants in a program would fit in 13 <a href="/wiki/Bit.html" title="Bit">bits</a>, yet almost every CPU design dedicated some multiple of 8 bits to storing them, typically 8, 16 or 32, one entire <a href="/wiki/Word_%28computer_science%29.html" title="Word (computer science)">word</a>. Taking this fact into account suggests that a machine should allow for constants to be stored in unused bits of the instruction itself, decreasing the number of memory accesses. Instead of loading up numbers from memory or registers, they would be "right there" when the CPU needed them, and therefore much faster. However this required the operation itself to be very small, otherwise there would not be enough room left over in a 32-bit instruction to hold reasonably sized constants.</p>
<p>Since real-world programs spent most of their time executing very simple operations, some researchers decided to focus on making those common operations as simple and as fast as possible. Since the clock rate of the CPU is limited by the time it takes to execute the <i>slowest</i> instruction, speeding up that instruction -- perhaps by reducing the number of addressing modes it supports -- also speeds up the execution of every other instruction. The goal of RISC was to make instructions so simple, each one could be executed in a single clock cycle <a  class="external autonumber" title="http://www.ercb.com/ddj/1990/ddj.9009.html">[1]</a>. The focus on "reduced instructions" led to the resulting machine being called a "reduced instruction set computer" (RISC).</p>
<p>Unfortunately, the term "reduced instruction set computer" is often misunderstood as meaning that there are fewer instructions in the <a href="/wiki/Instruction_set.html" title="Instruction set">instruction set</a> of the processor. Instead, RISC designs often have huge command sets of their own. Inspired by the desire for simpler designs, some people have developed some interesting <a href="/wiki/Misc.html" title="Misc">MISC</a> and <a href="/wiki/OISC.html" title="OISC">OISC</a> machines such as <a href="/wiki/Transport_Triggered_Architectures.html" title="Transport Triggered Architectures">Transport Triggered Architectures</a>, while others have walked into a <a href="/wiki/Turing_tarpit.html" title="Turing tarpit">Turing tarpit</a>.</p>
<p>The real difference between RISC and CISC is the philosophy of doing everything in registers and loading and saving the data to and from them. To avoid that misunderstanding, many researchers prefer the term <i>load-store</i>.</p>
<p>Over time the older design technique became known as <i><a href="/wiki/Complex_Instruction_Set_Computer.html" title="Complex Instruction Set Computer">Complex Instruction Set Computer</a></i>, or <i>CISC</i>, although this was largely to give them a different name for comparison purposes.</p>
<p>Code was implemented as a series of these simple instructions, instead of a single complex instruction that had the same result. This had the side effect of leaving more room in the instruction to carry data with it, meaning that there was less need to use registers or memory. At the same time the memory interface was considerably simpler, allowing it to be tuned.</p>
<p>However RISC also had its drawbacks. Since a series of instructions is needed to complete even simple tasks, the total number of instructions read from memory is larger, and therefore takes longer. At the time it was not clear whether or not there would be a net gain in performance due to this limitation, and there was an almost continual battle in the press and design world about the RISC concepts.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Meanwhile...">edit</a>]</div>
<p><a name="Meanwhile..." id="Meanwhile..."></a></p>
<h2>Meanwhile...</h2>
<p>While the RISC philosophy was coming into its own, new ideas about how to dramatically increase performance of the CPUs were starting to develop.</p>
<p>In the early 1980s it was thought that existing design was reaching theoretical limits. Future improvements in speed would be primarily through improved <a href="/wiki/Semiconductor.html" title="Semiconductor">semiconductor</a> "process", that is, smaller features (<a href="/wiki/Transistors.html" title="Transistors">transistors</a> and wires) on the chip. The complexity of the chip would remain largely the same, but the smaller size would allow it to run at higher clock rates. A considerable amount of effort was put into designing chips for <a href="/wiki/Parallel_computing.html" title="Parallel computing">parallel computing</a>, with built-in communications links. Instead of making faster chips, a large number of chips would be used, dividing up problems among them. However history has shown that the original fears were not valid, and there were a number of ideas that dramatically improved performance in the late 1980s.</p>
<p>One idea was to include a <a href="/wiki/Instruction_pipeline.html" title="Instruction pipeline">pipeline</a> which would break down instructions into steps, and work on one step of several different instructions at the same time. A normal processor might read an instruction, decode it, fetch the memory the instruction asked for, perform the operation, and then write the results back out. The key to pipelining is the observation that the processor can start reading the next instruction as soon as it finishes reading the last, meaning that there are now two instructions being worked on (one is being read, the next is being decoded), and after another cycle there will be three. While no single instruction is completed any faster, the <i>next</i> instruction would complete right after the previous one. The result was a much more efficient utilization of processor resources.</p>
<p>Yet another solution was to use several processing elements inside the processor and run them in parallel. Instead of working on one instruction to add two numbers, these <a href="/wiki/Superscalar.html" title="Superscalar">superscalar</a> processors would look at the next instruction in the pipeline and attempt to run it at the same time in an identical unit. However, this can be difficult to do, as many instructions in computing depend on the results of some other instruction.</p>
<p>Both of these techniques relied on increasing speed by adding complexity to the basic layout of the CPU, as opposed to the instructions running on them. With chip space being a finite quantity, in order to include these features something else would have to be removed to make room. RISC was tailor-made to take advantage of these techniques, because the core logic of a RISC CPU was considerably simpler than in CISC designs. Although the first RISC designs had marginal performance, they were able to quickly add these new design features and by the late 1980s they were significantly outperforming their CISC counterparts. In time this would be addressed as process improved to the point where all of this could be added to a CISC design and still fit on a single chip, but this took most of the late-80s and early 90s.</p>
<p>The long and short of it is that for any given level of general performance, a RISC chip will typically have many fewer <a href="/wiki/Transistor.html" title="Transistor">transistors</a> dedicated to the core logic. This allows the designers considerable flexibility; they can, for instance:</p>
<ul>
<li>increase the size of the register set</li>
<li>implement measures to increase internal parallelism</li>
<li>increase the size of <a href="/wiki/CPU_cache.html" title="CPU cache">caches</a></li>
<li>add other functionality, like I/O and timers for microcontrollers</li>
<li>add vector (<a href="/wiki/SIMD.html" title="SIMD">SIMD</a>) processors like <a href="/wiki/AltiVec.html" title="AltiVec">AltiVec</a> and <a href="/wiki/Streaming_SIMD_Extensions.html" title="Streaming SIMD Extensions">Streaming SIMD Extensions</a> (SSE)</li>
<li>build the chips on older fabrication lines, which would otherwise go unused</li>
<li>do nothing; offer the chip for <a href="/wiki/Battery_%28electricity%29.html" title="Battery (electricity)">battery</a>-constrained or size-limited applications</li>
</ul>
<p>Features which are generally found in RISC designs are:</p>
<ul>
<li>uniform instruction encoding (for example the op-code is always in the same bit position in each instruction, which is always one word long), which allows faster decoding;</li>
<li>a homogeneous register set, allowing any register to be used in any context and simplifying compiler design (although there are almost always separate <a href="/wiki/Integer.html" title="Integer">integer</a> and <a href="/wiki/Floating_point.html" title="Floating point">floating point</a> register files);</li>
<li>simple <a href="/wiki/Addressing_mode.html" title="Addressing mode">addressing modes</a> (complex addressing modes are replaced by sequences of simple arithmetic instructions);</li>
<li>few data types supported in hardware (for example, some CISC machines had instructions for dealing with <a href="/wiki/Byte.html" title="Byte">byte</a> <a href="/wiki/String_%28computer_science%29.html" title="String (computer science)">strings</a>. Others had support for polynomials and <a href="/wiki/Complex_number.html" title="Complex number">complex numbers</a>. Such instructions are unlikely to be found on a RISC machine).</li>
</ul>
<p>RISC designs are also more likely to feature a <a href="/wiki/Harvard_architecture.html" title="Harvard architecture">Harvard memory model</a>, where the instruction stream and the data stream are conceptually separated; this means that modifying the addresses where code is held might not have any effect on the instructions executed by the processor (because the CPU has a separate instruction and data <a href="/wiki/Cache.html" title="Cache">cache</a>), at least until a special synchronization instruction is issued. On the upside, this allows both caches to be accessed simultaneously, which can often improve performance.</p>
<p>Many of these early RISC designs also shared a not-so-nice feature, the <a href="/wiki/Branch_delay_slot.html" title="Branch delay slot">branch delay slot</a>. A branch delay slot is an instruction space immediately following a jump or branch. The instruction in this space is executed whether or not the branch is taken (in other words the effect of the branch is delayed). This instruction keeps the <a href="/wiki/Arithmetic_and_logical_unit.html" title="Arithmetic and logical unit">ALU</a> of the CPU busy for the extra time normally needed to perform a branch. Nowadays the branch delay slot is considered an unfortunate side effect of a particular strategy for implementing some RISC designs, and modern RISC designs generally do away with it (such as PowerPC, more recent versions of SPARC, and MIPS).</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Early RISC">edit</a>]</div>
<p><a name="Early_RISC" id="Early_RISC"></a></p>
<h2>Early RISC</h2>
<p>The first system that would today be known as RISC was not at the time; it was the <a href="/wiki/CDC_6600.html" title="CDC 6600">CDC 6600</a> <a href="/wiki/Supercomputer.html" title="Supercomputer">supercomputer</a>, designed in 1964 by Jim Thornton and <a href="/wiki/Seymour_Cray.html" title="Seymour Cray">Seymour Cray</a>. Thornton and Cray designed it as a number-crunching CPU (with 74 op-codes, compared with a <a href="/wiki/Intel_8086.html" title="Intel 8086">8086</a>'s 400) plus 12 simple computers called "peripheral processors" to handle I/O (most of the operating system was in one of these). The CDC 6600 had a load-store architecture with only two <a href="/wiki/Addressing_mode.html" title="Addressing mode">addressing modes</a>. There were eleven pipelined functional units for arithmetic and logic, plus five load units and two store units (the memory had multiple banks so all load-store units could operate at the same time). The basic clock cycle/instruction issue rate was 10 times faster than the memory access time.</p>
<p>Another early load-store machine was the <a href="/wiki/Data_General_Nova.html" title="Data General Nova">Data General Nova</a> minicomputer, designed in 1968.</p>
<p>The most public RISC designs, however, were the results of university research programs run with funding from the <a href="/wiki/DARPA.html" title="DARPA">DARPA</a> <a href="/wiki/VLSI.html" title="VLSI">VLSI</a> Program. The VLSI Program, practically unknown today, led to a huge number of advances in chip design, fabrication, and even computer graphics.</p>
<p><a href="/wiki/UC_Berkeley.html" title="UC Berkeley">UC Berkeley</a>'s <a href="/wiki/Berkeley_RISC.html" title="Berkeley RISC">RISC project</a> started in 1980 under the direction of <a href="/wiki/David_A._Patterson.html" title="David A. Patterson">David Patterson</a>, based on gaining performance through the use of pipelining and an aggressive use of registers known as <a href="/wiki/Register_window.html" title="Register window">register windows</a>. In a normal CPU one has a small number of registers, and a program can use any register at any time. In a CPU with <a href="/wiki/Register_window.html" title="Register window">register windows</a>, there are a huge number of registers, 128, but programs can only use a small number of them, 8, at any one time. A program that limits itself to 8 registers per procedure can make very fast procedure calls: The call, and the return, simply move the window to the set of 8 registers used by that procedure. (On a normal CPU, most calls "flush" the contents of the registers to RAM to clear enough working space for the subroutine, and the return "restores" those values).</p>
<p>The RISC project delivered the RISC-I processor in 1982. Consisting of only 44,420 transistors (compared with averages of about 100,000 in newer CISC designs of the era) RISC-I had only 32 instructions, and yet completely outperformed any other single-chip design. They followed this up with the 40,760 transistor, 39 instruction RISC-II in 1983, which ran over three times as fast as RISC-I.</p>
<p>At about the same time, <a href="/wiki/John_L._Hennessy.html" title="John L. Hennessy">John L. Hennessy</a> started a similar project called <a href="/wiki/MIPS_architecture.html" title="MIPS architecture">MIPS</a> at <a href="/wiki/Stanford_University.html" title="Stanford University">Stanford University</a> in 1981. MIPS focussed almost entirely on the pipeline, making sure it could be run as "full" as possible. Although pipelining was already in use in other designs, several features of the MIPS chip made its pipeline far faster. The most important, and perhaps annoying, of these features was the demand that all instructions be able to complete in one cycle. This demand allowed the pipeline to be run at much higher speeds (there was no need for induced delays) and is responsible for much of the processor's speed. However, it also had the negative side effect of eliminating many potentially useful instructions, like a multiply or a divide.</p>
<p>The earliest attempt to make a chip-based RISC CPU was a project at <a href="/wiki/International_Business_Machines.html" title="International Business Machines">IBM</a> which started in 1975, predating both of the projects above. Named after the building where the project ran, the work led to the <a href="/wiki/IBM_801.html" title="IBM 801">IBM 801</a> CPU family which was used widely inside IBM hardware. The 801 was eventually produced in a single-chip form as the <b>ROMP</b> in 1981, which stood for <i>Research (Office Products Division) Mini Processor</i>. As the name implies, this CPU was designed for "mini" tasks, and when IBM released the <a href="/wiki/IBM_RT-PC.html" title="IBM RT-PC">IBM RT-PC</a> based on the design in 1986, the performance was not acceptable. Nevertheless the 801 inspired several research projects, including new ones at IBM that would eventually lead to their <a href="/wiki/IBM_POWER.html" title="IBM POWER">POWER</a> system.</p>
<p>In the early years, the RISC efforts were well known, but largely confined to the university labs that had created them. The Berkeley effort became so well known that it eventually became the name for the entire concept. Many in the computer industry criticized that the performance benefits were unlikely to translate into real-world settings due to the decreased memory efficiency of multiple instructions, and that that was the reason no one was using them. But starting in 1986, all of the RISC research projects started delivering products. In fact, almost all modern RISC processors are direct copies of the RISC-II design.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Later RISC">edit</a>]</div>
<p><a name="Later_RISC" id="Later_RISC"></a></p>
<h2>Later RISC</h2>
<p>Berkeley's research was not directly commercialized, but the RISC-II design was used by <a href="/wiki/Sun_Microsystems.html" title="Sun Microsystems">Sun Microsystems</a> to develop the <a href="/wiki/SPARC.html" title="SPARC">SPARC</a>, by <a href="/wiki/Pyramid_Technology.html" title="Pyramid Technology">Pyramid Technology</a> to develop their line of mid-range multi-processor machines, and by almost every other company a few years later. It was Sun's use of a RISC chip in their new machines that demonstrated that RISC's benefits were real, and their machines quickly outpaced the competition and essentially took over the entire <a href="/wiki/Workstation.html" title="Workstation">workstation</a> market.</p>
<p>John Hennessy left Stanford (temporarily) to commercialize the MIPS design, starting the company known as <a href="/wiki/MIPS_Computer_Systems.html" title="MIPS Computer Systems">MIPS Computer Systems</a> Their first design was a second-generation MIPS chip known as the <b><a href="/wiki/R2000.html" title="R2000">R2000</a></b>. MIPS designs went on to become one of the most used RISC chips when they were included in the <a href="/wiki/PlayStation.html" title="PlayStation">PlayStation</a> and <a href="/wiki/Nintendo_64.html" title="Nintendo 64">Nintendo 64</a> <a href="/wiki/Game_console.html" title="Game console">game consoles</a>. Today they are one of the most common <a href="/wiki/Embedded_processor.html" title="Embedded processor">embedded processors</a> in use for high-end applications.</p>
<p>IBM learned from the RT-PC failure and would go on to design the RS/6000 based on their new POWER architecture. They then moved their existing <a href="/wiki/AS/400.html" title="AS/400">AS/400</a> systems to POWER chips, and found much to their surprise that even the very complex instruction set ran considerably faster. The result was the new <a href="/wiki/ISeries.html" title="ISeries">iSeries</a>. POWER would also find itself moving "down" in scale to produce the <a href="/wiki/PowerPC.html" title="PowerPC">PowerPC</a> design, which eliminated many of the "IBM only" instructions and created a single-chip implementation. Today the PowerPC is one of the most commonly used CPUs for automotive applications (some cars have over 10 of them inside). It is also the CPU used in most <a href="/wiki/Apple_Macintosh.html" title="Apple Macintosh">Apple Macintosh</a> machines sold until 2006 (starting February 2006 Apple is switching their PowerPC products for Intel Core processors).</p>
<p>Almost all other vendors quickly joined. From the <a href="/wiki/United_Kingdom.html" title="United Kingdom">UK</a> similar research efforts resulted in the <a href="/wiki/INMOS_Transputer.html" title="INMOS Transputer">INMOS Transputer</a>, the <a href="/wiki/Acorn_Archimedes.html" title="Acorn Archimedes">Acorn Archimedes</a> and the <a href="/wiki/ARM_Ltd.html" title="ARM Ltd">Advanced RISC Machine</a> line, which is a huge success today. Companies with existing CISC designs also quickly joined the revolution. <a href="/wiki/Intel.html" title="Intel">Intel</a> released the <a href="/wiki/Intel_i860.html" title="Intel i860">i860</a> and <a href="/wiki/Intel_i960.html" title="Intel i960">i960</a> by the late 1980s, although they were not very successful. <a href="/wiki/Motorola.html" title="Motorola">Motorola</a> built a new design called the <a href="/wiki/Motorola_88000.html" title="Motorola 88000">88000</a> in homage to their famed CISC <a href="/wiki/Motorola_68000.html" title="Motorola 68000">68000</a>, but it saw almost no use and they eventually abandoned it and joined IBM to produce the PowerPC. <a href="/wiki/AMD.html" title="AMD">AMD</a> released their <a href="/wiki/AMD_29000.html" title="AMD 29000">29000</a> which would go on to become the most popular RISC design of the early 1990s.</p>
<p>Today RISC CPUs (and <a href="/wiki/Microcontroller.html" title="Microcontroller">microcontrollers</a>) represent the vast majority of all CPUs in use. The RISC design technique offers power in even small sizes, and thus has come to completely dominate the market for low-power "embedded" CPUs. Embedded CPUs are by far the largest market for processors: while a family may own one or two PCs, their car(s), cell phones, and other devices may contain a total of dozens of embedded processors. RISC had also completely taken over the market for larger workstations for much of the 90s. After the release of the Sun SPARCstation the other vendors rushed to compete with RISC based solutions of their own. Even the mainframe world is now completely RISC based.</p>
<p>However, despite many successes, RISC has made few inroads into the desktop PC and commodity server markets, where <a href="/wiki/Intel.html" title="Intel">Intel</a>'s <a href="/wiki/X86.html" title="X86">x86</a> platform remains the dominant processor architecture (<a href="/wiki/Intel.html" title="Intel">Intel</a> is facing increased competition from <a href="/wiki/AMD.html" title="AMD">AMD</a>, but even AMD's processors implement the <a href="/wiki/X86.html" title="X86">x86</a> platform, or a 64-bit superset known as <a href="/wiki/X86-64.html" title="X86-64">x86-64</a>). There are three main reasons for this. One, the very large base of <a href="/wiki/Proprietary_software.html" title="Proprietary software">proprietary</a> PC applications are written for x86, whereas no RISC platform has a similar installed base, and this meant PC users were locked into the x86 despite a lack of performance. The second is that, although RISC was indeed able to scale up in performance quite quickly and cheaply, Intel took advantage of its large market by spending enormous amounts of money on processor development. Intel could spend many times as much as any RISC manufacturer on improvements in design and manufacturing, making up for inherent flaws in the basic x86 architecture. The third reason is that Intel designers realized that they could apply RISC design philosophies and practices to their architecture. For example, the P6 core of the PentiumPro processor and its successors has special functional units which expand, or "crack", the majority of the CISC instructions into multiple simpler RISC operations. Internally, processors using the P6 core are RISC machines that emulate a CISC architecture.</p>
<p>Consumers are interested in speed, cost per chip, and compatibility with existing software rather than the cost of development of new chips. This has led to an interesting chain of events. As the complexity of developing more and more advanced CPUs increases, the cost of both development and fabrication of high-end CPUs has exploded. The cost gains RISC gave to the CPU designer are now dwarfed by the high costs of developing any modern CPU, and today only the biggest chip makers are capable of making high performing CPUs. The end result is that virtually all RISC platforms with the exception of IBM's <a href="/wiki/Power_Architecture.html" title="Power Architecture">Power Architecture</a> have greatly shrunk in scale of development of high performing CPUs (like SPARC and MIPS) or even abandoned (like Alpha and PA-RISC) during the 00s. As of 2004, x86 chips are the fastest CPUs in <a href="/wiki/SPECint.html" title="SPECint">SPECint</a> displacing all RISC CPUs, and the fastest CPU in <a href="/wiki/SPECfp.html" title="SPECfp">SPECfp</a> is the IBM Power 5 processor.</p>
<p>Still, RISC designs have led to a number of successful platforms and architectures, some of the larger ones being:</p>
<ul>
<li>MIPS's <a href="/wiki/MIPS_architecture.html" title="MIPS architecture">MIPS</a> line, found in most <a href="/wiki/Silicon_Graphics.html" title="Silicon Graphics">SGI</a> computers and the <a href="/wiki/PlayStation.html" title="PlayStation">PlayStation</a>, <a href="/wiki/PlayStation_2.html" title="PlayStation 2">PlayStation 2</a>, <a href="/wiki/PlayStation_Portable.html" title="PlayStation Portable">PlayStation Portable</a>, and <a href="/wiki/Nintendo_64.html" title="Nintendo 64">Nintendo 64</a> game consoles</li>
<li>IBM's and Freescale's (formerly <a href="/wiki/Motorola.html" title="Motorola">Motorola</a> SPS) <a href="/wiki/Power_Architecture.html" title="Power Architecture">Power Architecture</a>, used in all of IBM's supercomputers, midrange servers and workstations, in Apple's <a href="/wiki/Power_Macintosh.html" title="Power Macintosh">Power Macintosh</a> computers, in <a href="/wiki/Nintendo.html" title="Nintendo">Nintendo</a>'s <a href="/wiki/Nintendo_Gamecube.html" title="Nintendo Gamecube">Gamecube</a> and <a href="/wiki/Wii.html" title="Wii">Wii</a>, <a href="/wiki/Microsoft.html" title="Microsoft">Microsoft</a>'s <a href="/wiki/Xbox_360.html" title="Xbox 360">Xbox 360</a> and <a href="/wiki/Sony.html" title="Sony">Sony</a>'s <a href="/wiki/PlayStation_3.html" title="PlayStation 3">PlayStation 3</a> game consoles, and in a lot embeddes applications like printers and cars.</li>
<li><a href="/wiki/Sun_Microsystems.html" title="Sun Microsystems">Sun</a>'s <a href="/wiki/SPARC.html" title="SPARC">SPARC</a> and <a href="/wiki/UltraSPARC.html" title="UltraSPARC">UltraSPARC</a>, found in all of their later machines</li>
<li><a href="/wiki/Hewlett-Packard.html" title="Hewlett-Packard">Hewlett-Packard</a>'s <a href="/wiki/PA-RISC.html" title="PA-RISC">PA-RISC</a>, also known as HP/PA</li>
<li><a href="/wiki/DEC_Alpha.html" title="DEC Alpha">DEC Alpha</a>, still used in some of HP's workstation and servers.</li>
<li><a href="/wiki/ARM_architecture.html" title="ARM architecture">ARM</a> — <a href="/wiki/Palm%2C_Inc..html" title="Palm, Inc.">Palm, Inc.</a> originally used the (CISC) Motorola 680x0 processors in its early PDAs, but now uses (RISC) ARM processors in its latest PDAs. <a href="/wiki/Apple_Computer.html" title="Apple Computer">Apple Computer</a> uses the ARM 7TDMI in its <a href="/wiki/IPod.html" title="IPod">iPod</a> products. <a href="/wiki/Nintendo.html" title="Nintendo">Nintendo</a> uses an ARM7 CPU in the <a href="/wiki/Game_Boy_Advance.html" title="Game Boy Advance">Game Boy Advance</a> and <a href="/wiki/Nintendo_DS.html" title="Nintendo DS">Nintendo DS</a> handheld game systems. The small Korean company <a href="/wiki/Game_Park.html" title="Game Park">Game Park</a> also markets the GP32, which uses the ARM9 CPU. Also, many cell phones from, for example, <a href="/wiki/Nokia.html" title="Nokia">Nokia</a> are based on ARM designs.</li>
</ul>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Alternative term">edit</a>]</div>
<p><a name="Alternative_term" id="Alternative_term"></a></p>
<h2>Alternative term</h2>
<p>Over many years, RISC instruction sets have tended to grow in size. Thus, some have started using the term "load-store" to describe RISC processors, since this is the key element of all such designs. Instead of the CPU itself handling many addressing modes, a load-store architecture uses a separate unit dedicated to handling very simple forms of load and store operations. CISC processors are then termed "register-memory" or "memory-memory".</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: See also">edit</a>]</div>
<p><a name="See_also" id="See_also"></a></p>
<h2>See also</h2>
<ul>
<li><a href="/wiki/Addressing_mode.html" title="Addressing mode">addressing mode</a></li>
<li><a href="/wiki/Complex_instruction_set_computer.html" title="Complex instruction set computer">CISC</a></li>
<li><a href="/wiki/VLIW.html" title="VLIW">VLIW</a></li>
<li><a href="/wiki/Misc.html" title="Misc">MISC</a></li>
<li><a href="/wiki/ZISC.html" title="ZISC">ZISC</a></li>
<li><a href="/wiki/Microprocessor.html" title="Microprocessor">microprocessor</a></li>
<li><a href="/wiki/Instruction_set_architecture.html" title="Instruction set architecture">instruction set architecture</a></li>
<li><a href="/wiki/Computer_architecture.html" title="Computer architecture">computer architecture</a></li>
<li><a href="/wiki/Classic_RISC_pipeline.html" title="Classic RISC pipeline">Classic RISC pipeline</a></li>
<li><a  class="external text" title="http://groups.google.com.au/group/comp.arch/msg/e86bb8d069bf56a6">John Mashey's comp.arch RISC vs CISC ... 1997</a> (<a href="/wiki/RISCvsCISC.html" title="RISCvsCISC">RISC vs CISC wikified</a>)</li>
</ul>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: External links">edit</a>]</div>
<p><a name="External_links" id="External_links"></a></p>
<h2>External links</h2>
<ul>
<li><a  class="external text" title="http://cse.stanford.edu/class/sophomore-college/projects-00/risc/risccisc/">RISC vs. CISC</a></li>
<li><a  class="external text" title="http://cse.stanford.edu/class/sophomore-college/projects-00/risc/whatis/index.html">What is RISC</a></li>
</ul>


<!-- Saved in parser cache with key enwiki:pcache:idhash:26201-0!1!0!default!!en!2 and timestamp 20060906010254 -->
<div class="printfooter">
Retrieved from "<a </div>
			<div id="catlinks"><p class='catlinks'><a  title="Special:Categories">Categories</a>: <span dir='ltr'><a  title="Category:Central processing unit">Central processing unit</a></span> | <span dir='ltr'><a  title="Category:Instruction processing">Instruction processing</a></span></p></div>			<!-- end content -->
			<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<ul>
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Reduced_instruction_set_computer.html">Article</a></li>
				 <li id="ca-talk"><a >Discussion</a></li>
				 <li id="ca-edit"><a >Edit this page</a></li>
				 <li id="ca-history"><a >History</a></li>
		</ul>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a >Sign in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(/images/wiki-en.png);" href="/wiki/Main_Page.html" title="Main Page"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage"><a href="/wiki/Main_Page.html">Main Page</a></li>
				<li id="n-portal"><a >Community Portal</a></li>
				<li id="n-Featured-articles"><a >Featured articles</a></li>
				<li id="n-currentevents"><a >Current events</a></li>
				<li id="n-recentchanges"><a >Recent changes</a></li>
				<li id="n-randompage"><a >Random article</a></li>
				<li id="n-help"><a >Help</a></li>
				<li id="n-contact"><a >Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a >Donations</a></li>
			</ul>
		</div>
	</div>
		<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/wiki/Special:Search" id="searchform"><div>
				<input id="searchInput" name="search" type="text" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" value="Search" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a >What links here</a></li>
				<li id="t-recentchangeslinked"><a >Related changes</a></li>
<li id="t-upload"><a >Upload file</a></li>
<li id="t-specialpages"><a >Special pages</a></li>
				<li id="t-print"><a >Printable version</a></li>				<li id="t-permalink"><a >Permanent link</a></li><li id="t-cite"><a >Cite this article</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>In other languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-bs"><a >Bosanski</a></li>
				<li class="interwiki-ca"><a >Català</a></li>
				<li class="interwiki-cs"><a >Česky</a></li>
				<li class="interwiki-da"><a >Dansk</a></li>
				<li class="interwiki-de"><a >Deutsch</a></li>
				<li class="interwiki-es"><a >Español</a></li>
				<li class="interwiki-fr"><a >Français</a></li>
				<li class="interwiki-ko"><a >한국어</a></li>
				<li class="interwiki-hr"><a >Hrvatski</a></li>
				<li class="interwiki-he"><a >עברית</a></li>
				<li class="interwiki-lt"><a >Lietuvių</a></li>
				<li class="interwiki-hu"><a >Magyar</a></li>
				<li class="interwiki-nl"><a >Nederlands</a></li>
				<li class="interwiki-ja"><a >日本語</a></li>
				<li class="interwiki-nn"><a >Norsk (nynorsk)</a></li>
				<li class="interwiki-pl"><a >Polski</a></li>
				<li class="interwiki-pt"><a >Português</a></li>
				<li class="interwiki-ru"><a >Русский</a></li>
				<li class="interwiki-sk"><a >Slovenčina</a></li>
				<li class="interwiki-sl"><a >Slovenščina</a></li>
				<li class="interwiki-fi"><a >Suomi</a></li>
				<li class="interwiki-sv"><a >Svenska</a></li>
				<li class="interwiki-th"><a >ไทย</a></li>
				<li class="interwiki-vi"><a >Tiếng Việt</a></li>
				<li class="interwiki-tr"><a >Türkçe</a></li>
				<li class="interwiki-zh"><a >中文</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a ><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="MediaWiki" /></a></div>
				<div id="f-copyrightico"><a ><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
				<li id="lastmod"> This page was last modified 07:39, 4 September 2006.</li>
				<li id="copyright">All text is available under the terms of the <a class='internal'  title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal'  title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the Wikimedia Foundation, Inc.<br /></li>
				<li id="privacy"><a  title="wikimedia:Privacy policy">Privacy policy</a></li>
				<li id="about"><a  title="Wikipedia:About">About Wikipedia</a></li>
				<li id="disclaimer"><a  title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
		
	
		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
</div>
<!-- Served by srv60 in 0.142 secs. --></body></html>
