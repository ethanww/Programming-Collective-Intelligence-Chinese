<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="keywords" content="Compiler optimization,Tail recursion,Iteration,Bounds-checking elimination,Recursion,ML programming language,Integer linear programming,Functional language,Lisp programming language,Java programming language,Basic block" />
<link rel="shortcut icon"  />
<link rel="search" type="application/opensearchdescription+xml"  />
<link rel="copyright"  />
		<title>Compiler optimization - Wikipedia, the free encyclopedia</title>
		<style type="text/css" media="screen,projection">/*<![CDATA[*/ @import "/skins-1.5/monobook/main.css?9"; /*]]>*/</style>
		<link rel="stylesheet" type="text/css" media="print"  />
		<!--[if lt IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE50Fixes.css";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE55Fixes.css";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/skins-1.5/monobook/IE60Fixes.css";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/skins-1.5/monobook/IE70Fixes.css?1";</style><![endif]-->
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
		
		<script type= "text/javascript">
			var skin = "monobook";
			var stylepath = "/skins-1.5";

			var wgArticlePath = "/wiki/$1";
			var wgScriptPath = "/w";
			var wgServer = "http://en.wikipedia.org";
                        
			var wgCanonicalNamespace = "";
			var wgNamespaceNumber = 0;
			var wgPageName = "Compiler_optimization";
			var wgTitle = "Compiler optimization";
			var wgArticleId = 40355;
			var wgIsArticle = true;
                        
			var wgUserName = null;
			var wgUserLanguage = "en";
			var wgContentLanguage = "en";
		</script>
		                
		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?1"><!-- wikibits js --></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js"><!-- site js --></script>
		<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Common.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=MediaWiki:Monobook.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=-&action=raw&gen=css&maxage=2678400";
/*]]>*/</style>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js"></script>
	</head>
<body  class="mediawiki ns-0 ltr">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><div style="text-align:right; font-size:80%">Your <b><a  class="extiw" title="wikimedia:Fundraising">continued donations</a></b> keep Wikipedia running!&nbsp;&nbsp;&nbsp;&nbsp;</div>
</div>		<h1 class="firstHeading">Compiler optimization</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a >navigation</a>, <a >search</a></div>			<!-- start content -->
			<p><b>Compiler optimization</b> is the process of tuning the output of a <a href="/wiki/Compiler.html" title="Compiler">compiler</a> to minimise some attribute (or maximise the efficiency) of an <a href="/wiki/Executable.html" title="Executable">executable</a> program. The most common requirement is to minimise the time taken to execute a <a href="/wiki/Computer_program.html" title="Computer program">program</a>; a less common one is to minimise the amount of <a href="/wiki/Memory_%28computers%29.html" title="Memory (computers)">memory</a> occupied, and the growth of <a href="/wiki/Portable_computer.html" title="Portable computer">portable computers</a> has created a market for minimising the power consumed by a program.</p>
<p>It has been shown that some code optimization problems are <a href="/wiki/NP-complete.html" title="NP-complete">NP-complete</a>. In practice factors such as <a href="/wiki/Programmer.html" title="Programmer">programmer</a> willingness to wait for the compiler to complete its task place upper limits on the optimizations that a compiler implementor might provide (optimization is a very <a href="/wiki/CPU.html" title="CPU">CPU</a> and memory intensive process). In the past computer memory limitations were also a major factor in limiting which optimizations could be performed.</p>
<p>Compiler vendors often advertise their products as being <i>optimizing compilers</i> and the ability of a compiler to optimise code can affect its sales and the regard programmers have for it.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a ><span class="tocnumber">1</span> <span class="toctext">Types of optimizations</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">2</span> <span class="toctext">Factors affecting optimization</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">3</span> <span class="toctext">Intended use of the generated code</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">4</span> <span class="toctext">Optimization techniques</span></a>
<ul>
<li class="toclevel-2"><a ><span class="tocnumber">4.1</span> <span class="toctext">Common themes</span></a></li>
<li class="toclevel-2"><a ><span class="tocnumber">4.2</span> <span class="toctext">Optimization techniques</span></a>
<ul>
<li class="toclevel-3"><a ><span class="tocnumber">4.2.1</span> <span class="toctext">Loop optimizations</span></a></li>
<li class="toclevel-3"><a ><span class="tocnumber">4.2.2</span> <span class="toctext">Data-flow optimizations</span></a></li>
<li class="toclevel-3"><a ><span class="tocnumber">4.2.3</span> <span class="toctext">SSA-based optimizations</span></a></li>
<li class="toclevel-3"><a ><span class="tocnumber">4.2.4</span> <span class="toctext">Code generator optimizations</span></a></li>
<li class="toclevel-3"><a ><span class="tocnumber">4.2.5</span> <span class="toctext">Functional language optimizations</span></a></li>
<li class="toclevel-3"><a ><span class="tocnumber">4.2.6</span> <span class="toctext">Other optimizations</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a ><span class="tocnumber">4.3</span> <span class="toctext">Interprocedural optimizations</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a ><span class="tocnumber">5</span> <span class="toctext">Problems with optimization</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">6</span> <span class="toctext">List of compiler optimizations</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">7</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<p><script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script></p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Types of optimizations">edit</a>]</div>
<p><a name="Types_of_optimizations" id="Types_of_optimizations"></a></p>
<h2>Types of optimizations</h2>
<p>Techniques in optimization can be broken up along various <i>scopes</i> which affect anywhere from a single statement to an entire program. Generally locally scoped techniques are easier to implement than global ones but result in lesser gains. Some examples of scopes include:</p>
<ul>
<li><a href="/wiki/Peephole_optimizations.html" title="Peephole optimizations">Peephole optimizations</a>: Usually performed late in the compilation process after <a href="/wiki/Machine_code.html" title="Machine code">machine code</a> has been generated. This form of optimization examines a few adjacent instructions (like looking through a peephole at the code) to see whether they can be replaced by a single instruction or a shorter sequence of instructions. For instance, a multiplication of a value by two might be more efficiently executed by shifting the value left or by adding the value to itself (this example is also an instance of <a href="/wiki/Strength_reduction.html" title="Strength reduction">strength reduction</a>).</li>
</ul>
<ul>
<li>Local or <i>intraprocedural</i> optimizations: These only consider information local to a function definition. This reduces the amount of analysis that needs to be performed (saving time and reducing storage requirements) but means that worst case assumptions have to be made when function calls occur or global variables are accessed (because little information about them is available).</li>
</ul>
<ul>
<li><i>Interprocedural</i> or whole-program optimization: These analyse all of a programs source code. The greater quantity of information extracted means that optimizations can be more effective compared to when they only have access to local information (ie, within a single function). This kind of optimization can also allow new techniques to be performed. For instance function <a href="/wiki/Inline_expansion.html" title="Inline expansion">inlining</a>, where a call to a function is replaced by a copy of the function body.</li>
</ul>
<ul>
<li><a href="/wiki/Loop_optimizations.html" title="Loop optimizations">Loop optimizations</a>: These act on the statements which make up a loop, such as a <i>for</i> loop (eg, <a href="/wiki/Loop-invariant_code_motion.html" title="Loop-invariant code motion">loop-invariant code motion</a>). Loop optimizations can have a significant impact because many programs spend a large percentage of their time inside loops.</li>
</ul>
<p>In addition to scoped optimizations there are two further general categories of optimization:</p>
<ul>
<li><i><a href="/wiki/Programming_language.html" title="Programming language">programming language</a>-independent vs. language-dependent</i>: Most high-level languages share common programming constructs and abstractions--decision (if, switch, case), looping (for, while, repeat .. until, do .. while), encapsulation (structures, objects). Thus similar optimization techniques can be used across languages. However certain language features make some kinds of optimizations possible and/or difficult. For instance, the existence of pointers in <a href="/wiki/C_programming_language.html" title="C programming language">C</a> and <a href="/wiki/C%2B%2B.html" title="C++">C++</a> makes certain optimizations of array accesses difficult. Conversely, in some languages functions are not permitted to have "side effects". Therefore, if repeated calls to the same function with the same arguments are made, the compiler can immediately infer that results need only be computed once and the result referred to repeatedly.</li>
</ul>
<ul>
<li><i>machine independent vs. machine dependent</i>: Many optimizations that operate on abstract programming concepts (loops, objects, structures) are independent of the machine targeted by the compiler. But many of the most effective optimizations are those that best exploit special features of the target platform.</li>
</ul>
<p>The following is an instance of a local machine dependent optimization. To set a register to 0, the obvious way is to use the constant 0 in an instruction that sets a register value to a constant. A less obvious way is to <a href="/wiki/XOR.html" title="XOR">XOR</a> a register with itself. It is up to the compiler to know which instruction variant to use. On many <a href="/wiki/RISC.html" title="RISC">RISC</a> machines, both instructions would be equally appropriate, since they would both be the same length and take the same time. On many other <a href="/wiki/Microprocessor.html" title="Microprocessor">microprocessors</a> such as the <a href="/wiki/Intel.html" title="Intel">Intel</a> <a href="/wiki/X86.html" title="X86">x86</a> family, it turns out that the XOR variant is shorter and probably faster, as there will be no need to decode an immediate operand, nor use the internal "immediate operand register". (The catch being that XOR may introduce a data dependency on the previous value of the register, causing a pipeline stall that makes execution slower than using setting the register to a constant 0.)</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Factors affecting optimization">edit</a>]</div>
<p><a name="Factors_affecting_optimization" id="Factors_affecting_optimization"></a></p>
<h2>Factors affecting optimization</h2>
<dl>
<dt><i>The machine itself</i></dt>
</dl>
<p>Many of the choices about which optimizations can and should be done depend on the characteristics of the target machine. It is sometimes possible to parameterize some of these machine dependent factors, so that a single piece of compiler code can be used to optimize different machines just by altering the machine description parameters. <a href="/wiki/GNU_Compiler_Collection.html" title="GNU Compiler Collection">GCC</a> is a compiler which exemplifies this approach.</p>
<dl>
<dt><i>The architecture of the target CPU</i></dt>
</dl>
<ul>
<li>Number of <a href="/wiki/Central_processing_unit.html" title="Central processing unit">CPU</a> <a href="/wiki/Processor_register.html" title="Processor register">registers</a>: To a certain extent, the more registers, the easier it is to optimize for performance. Local variables can be allocated in the registers and not on the <a href="/wiki/Call_stack.html" title="Call stack">stack</a>. Temporary/intermediate results can be left in registers without writing to and reading back from memory.</li>
<li><a href="/wiki/RISC.html" title="RISC">RISC</a> vs. <a href="/wiki/CISC.html" title="CISC">CISC</a>: CISC instruction sets often have variable instruction lengths, often have a larger number of possible instructions that can be used, and each instruction could take differing amounts of time. RISC instruction sets attempt to limit the variability in each of these: instruction sets are usually constant length, with few exceptions, there are usually fewer combinations of registers and memory operations, and the instruction issue rate (the number of instructions completed per time period, usually an integer multiple of the clock cycle) is usually constant in cases where memory latency is not a factor. There may be several ways of carrying out a certain task, with CISC usually offering more alternatives than RISC. Compilers have to know the relative costs among the various instructions and choose the best instruction sequence (see <a href="/wiki/Instruction_selection.html" title="Instruction selection">instruction selection</a>).</li>
<li><a href="/wiki/Instruction_pipeline.html" title="Instruction pipeline">Pipelines</a>: A pipeline is essentially an <a href="/wiki/ALU.html" title="ALU">ALU</a> broken up into an assembly line. It allows use of parts of the ALU for different instructions by breaking up the execution of instructions into various stages: instruction decode, address decode, memory fetch, register fetch, compute, register store, etc. One instruction could be in the register store stage, while another could be in the register fetch stage. Pipeline conflicts occur when an instruction in one stage of the pipeline depends on the result of another instruction ahead of it in the pipeline but not yet completed. Pipeline conflicts can lead to <a href="/wiki/Pipeline_stall.html" title="Pipeline stall">pipeline stalls</a>: where the CPU wastes cycles waiting for a conflict to resolve.</li>
</ul>
<dl>
<dd>Compilers can <i>schedule</i>, or reorder, instructions so that pipeline stalls occur less frequently.</dd>
</dl>
<ul>
<li><a href="/wiki/Superscalar.html" title="Superscalar">Number of functional units</a>: Some CPUs have several ALUs and <a href="/wiki/Floating_point_unit.html" title="Floating point unit">FPUs</a>. This allows them to execute multiple instructions simultaneously. There may be restrictions on which instructions can pair with which other instructions ("pairing" is the simultaneous execution of two or more instructions), and which functional unit can execute which instruction. They also have issues similar to pipeline conflicts.</li>
</ul>
<dl>
<dd>Here again, instructions have to be scheduled so that the various functional units are fully fed with instructions to execute.</dd>
</dl>
<dl>
<dt><i>The architecture of the machine</i></dt>
</dl>
<ul>
<li><a href="/wiki/CPU_Cache.html" title="CPU Cache">Cache</a> size (256kB-4MB) and type (direct mapped, 2-/4-/8-/16-way associative, fully associative): Techniques like <a href="/wiki/Inline_expansion.html" title="Inline expansion">inline expansion</a> and <a href="/wiki/Loop_unrolling.html" title="Loop unrolling">loop unrolling</a> may increase the size of the generated code and reduce code locality. The program may slow down drastically if an oft-run piece of code (like inner loops in various algorithms) suddenly cannot fit in the cache. Also, caches which are not fully associative have higher chances of cache collisions even in an unfilled cache.</li>
<li>Cache/Memory transfer rates: These give the compiler an indication of the penalty for cache misses. This is used mainly in specialized applications.</li>
</ul>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Intended use of the generated code">edit</a>]</div>
<p><a name="Intended_use_of_the_generated_code" id="Intended_use_of_the_generated_code"></a></p>
<h2>Intended use of the generated code</h2>
<dl>
<dt><i>Debugging</i>&#160;</dt>
<dd>When a programmer is still writing an application, they will recompile and test often, and so compilation must be fast. This is one reason most optimizations are avoided while debugging. Also, debugging code is usually stepped through in a <a  class="new" title="Symbolic debugger">symbolic debugger</a>, and optimizing transformations, particularly those that reorder code, can make it difficult to identify the output code with the line numbers in the source code from which the code was generated. This can confuse the debugging tools and the programmer using them.</dd>
</dl>
<dl>
<dt><i>General purpose use</i>&#160;</dt>
<dd>Prepackaged software is very often expected to be executed on a variety of machines and CPUs that may share the same instruction set, but have different timing, cache or memory characteristics. So, the code may not be tuned to any particular CPU, or may be tuned to work well on the most popular CPU and work reasonably on other CPUs.</dd>
</dl>
<dl>
<dt><i>Special purpose use</i>&#160;</dt>
<dd>If the software is compiled to be used on one or a few very similar machines, with known characteristics, then the compiler can heavily tune the generated code to those machines alone. Important special cases include code designed for <a href="/wiki/Parallel_computing.html" title="Parallel computing">parallel</a> and <a href="/wiki/Vector_processor.html" title="Vector processor">vector processors</a>, for which we have parallelizing compilers.</dd>
</dl>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Optimization techniques">edit</a>]</div>
<p><a name="Optimization_techniques" id="Optimization_techniques"></a></p>
<h2>Optimization techniques</h2>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Common themes">edit</a>]</div>
<p><a name="Common_themes" id="Common_themes"></a></p>
<h3>Common themes</h3>
<p>To a large extent, optimization techniques have the following themes, which sometime conflict.</p>
<dl>
<dt><i>Avoid redundancy</i>&#160;</dt>
<dd>If something has already been computed, it is generally better to store it and reuse it later, instead of recomputing it.</dd>
</dl>
<dl>
<dt><i>Less code</i>&#160;</dt>
<dd>There is less work for the CPU, cache, and memory. So, likely to be faster.</dd>
</dl>
<dl>
<dt><i>Straight line code, fewer jumps</i>&#160;</dt>
<dd>Less complicated code. Jumps interfere with the prefetching of instructions, thus slowing down code.</dd>
</dl>
<dl>
<dt><i>Code locality</i>&#160;</dt>
<dd>Pieces of code executed close together in time should be placed close together in memory, which increases spatial <a href="/wiki/Locality_of_reference.html" title="Locality of reference">locality of reference</a>.</dd>
</dl>
<dl>
<dt><i>Extract more information from code</i>&#160;</dt>
<dd>The more information the compiler has, the better it can optimize.</dd>
</dl>
<dl>
<dt><i>Avoid memory accesses</i>&#160;</dt>
<dd>Accessing memory, particularly if there is a cache miss, is much more expensive than accessing registers.</dd>
</dl>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Optimization techniques">edit</a>]</div>
<p><a name="Optimization_techniques_2" id="Optimization_techniques_2"></a></p>
<h3>Optimization techniques</h3>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Loop optimizations">edit</a>]</div>
<p><a name="Loop_optimizations" id="Loop_optimizations"></a></p>
<h4>Loop optimizations</h4>
<p>Please see more details in the main article <a href="/wiki/Loop_optimization.html" title="Loop optimization">loop optimization</a></p>
<p>Some optimization techniques primarily designed to operate on loops include:</p>
<dl>
<dt><a href="/wiki/Induction_variable_analysis.html" title="Induction variable analysis">induction variable analysis</a>&#160;</dt>
<dd>Roughly, if a variable in a loop is a simple function of the index variable, such as <code>j&#160;:= 4*i+1</code>, it can be updated appropriately each time the loop variable is changed. This is a <a href="/wiki/Strength_reduction.html" title="Strength reduction">strength reduction</a>, and also may allow the index variable's definitions to become <a href="/wiki/Dead_code.html" title="Dead code">dead code</a>. This information is also useful for <a href="/wiki/Bounds-checking_elimination.html" title="Bounds-checking elimination">bounds-checking elimination</a> and <a href="/wiki/Dependence_analysis.html" title="Dependence analysis">dependence analysis</a>, among other things.</dd>
</dl>
<dl>
<dt><a href="/wiki/Loop_fission.html" title="Loop fission">loop fission</a> or <i>loop distribution</i>&#160;</dt>
<dd>Loop fission attempts to break a loop into multiple loops over the same index range but each taking only a part of the loop's body. This can improve <a href="/wiki/Locality_of_reference.html" title="Locality of reference">locality of reference</a>, both of the data being accessed in the loop and the code in the loop's body.</dd>
</dl>
<dl>
<dt><a href="/wiki/Loop_fusion.html" title="Loop fusion">loop fusion</a> or <i>loop combining</i>&#160;</dt>
<dd>Another technique which attempts to reduce loop overhead. When two adjacent loops would iterate the same number of times (whether or not that number is known at compile time), their bodies can be combined as long as they make no reference to each other's data.</dd>
</dl>
<dl>
<dt><a href="/wiki/Loop_inversion.html" title="Loop inversion">loop inversion</a>&#160;</dt>
<dd>This technique changes a standard <i>while</i> loop into a <i>do/while</i> (also known as <i>repeat/until</i>) loop wrapped in an <i>if</i> conditional, reducing the number of jumps by two, for cases when the loop is executed. Doing so duplicates the condition check (increasing the size of the code) but is more efficient because jumps usually cause a <a href="/wiki/Pipeline_stall.html" title="Pipeline stall">pipeline stall</a>. Additionally, if the initial condition is known at compile-time and is known to be <a href="/wiki/Side-effect_%28computer_science%29.html" title="Side-effect (computer science)">side-effect</a>-free, the <i>if</i> guard can be skipped.</dd>
</dl>
<dl>
<dt><a href="/wiki/Loop_interchange.html" title="Loop interchange">loop interchange</a>&#160;</dt>
<dd>These optimizations exchange inner loops with outer loops. When the loop variables index into an array, such a transformation can improve <a href="/wiki/Locality_of_reference.html" title="Locality of reference">locality of reference</a>, depending on the array's layout.</dd>
</dl>
<dl>
<dt><a href="/wiki/Loop-invariant_code_motion.html" title="Loop-invariant code motion">loop-invariant code motion</a>&#160;</dt>
<dd>If a quantity is computed inside a loop during every iteration, and its value is the same for each iteration, it can vastly improve efficiency to hoist it outside the loop and compute its value just once before the loop begins. This is particularly important with the address-calculation expressions generated by loops over arrays. For correct implementation, this technique must be used with <a href="/wiki/Loop_inversion.html" title="Loop inversion">loop inversion</a>, because not all code is safe to be hoisted outside the loop.</dd>
</dl>
<dl>
<dt><a href="/wiki/Loop_nest_optimization.html" title="Loop nest optimization">loop nest optimization</a>&#160;</dt>
<dd>Some pervasive algorithms such as matrix multiplication have very poor cache behavior and excessive memory accesses. Loop nest optimization increases the number of cache hits by performing the operation over small blocks and by using a loop interchange.</dd>
</dl>
<dl>
<dt><a  class="new" title="Loop reversal">loop reversal</a>&#160;</dt>
<dd>Loop reversal reverses the order in which values are assigned to the index variable. This is a subtle optimization which can help eliminate <a href="/wiki/Dependence_analysis.html" title="Dependence analysis">dependencies</a> and thus enable other optimizations.</dd>
</dl>
<dl>
<dt><a href="/wiki/Loop_unrolling.html" title="Loop unrolling">loop unrolling</a>&#160;</dt>
<dd>Duplicates the body of the loop multiple times, in order to decrease the number of times the loop condition is tested and the number of jumps, which hurt performance by impairing the instruction pipeline. Completely unrolling a loop eliminates all overhead, but requires that the number of iterations be known at compile time.</dd>
</dl>
<dl>
<dt><a href="/wiki/Loop_splitting.html" title="Loop splitting">loop splitting</a>&#160;</dt>
<dd>Loop splitting attempts to simplify a loop or eliminate <a href="/wiki/Dependence_analysis.html" title="Dependence analysis">dependencies</a> by breaking it into multiple loops which have the same bodies but iterate over different contiguous portions of the index range. A useful special case is <i>loop peeling</i>, which can simplify a loop with a problematic first iteration by performing that iteration separately before entering the loop.</dd>
</dl>
<dl>
<dt><a href="/wiki/Loop_unswitching.html" title="Loop unswitching">loop unswitching</a>&#160;</dt>
<dd>Unswitching moves a conditional inside a loop outside of it by duplicating the loop's body, and placing a version of it inside each of the if and else clauses of the conditional.</dd>
</dl>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Data-flow optimizations">edit</a>]</div>
<p><a name="Data-flow_optimizations" id="Data-flow_optimizations"></a></p>
<h4>Data-flow optimizations</h4>
<p>Data flow optimizations, based on <a href="/wiki/Data-flow_analysis.html" title="Data-flow analysis">Data-flow analysis</a>, primarily depend on how certain properties of data are propagated by control edges in the <a href="/wiki/Control_flow_graph.html" title="Control flow graph">control flow graph</a>. Some of these include:</p>
<dl>
<dt><a href="/wiki/Common_subexpression_elimination.html" title="Common subexpression elimination">common subexpression elimination</a>&#160;</dt>
<dd>In the expression "(a+b)-(a+b)/4", "common subexpression" refers to the duplicated "(a+b)". Compilers implementing this technique realize that "(a+b)" won't change, and as such, only calculate its value once.</dd>
</dl>
<dl>
<dt><i><a href="/wiki/Constant_folding.html" title="Constant folding">constant folding</a> and <a href="/wiki/Constant_propagation.html" title="Constant propagation">propagation</a></i>&#160;</dt>
<dd>replacing expressions consisting of constants (e.g. "3 + 5") with their final value ("8") at compile time, rather than doing the calculation in run-time. Used in most modern languages.</dd>
</dl>
<dl>
<dt><i>Induction variable recognition and elimination</i></dt>
</dl>
<dl>
<dt><i><a href="/wiki/Aliasing_%28computing%29#Conflicts_with_optimisation.html" title="Aliasing (computing)">Alias classification and pointer analysis</a></i>&#160;</dt>
<dd>in the presence of <a href="/wiki/Pointer.html" title="Pointer">pointers</a>, it is difficult to make any optimisations at all, since potentially any variable can have been changed when a memory location is assigned to. By specifying which pointers can alias which variables, unrelated pointers can be ignored.</dd>
</dl>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: SSA-based optimizations">edit</a>]</div>
<p><a name="SSA-based_optimizations" id="SSA-based_optimizations"></a></p>
<h4><a href="/wiki/SSA_%28compilers%29.html" title="SSA (compilers)">SSA</a>-based optimizations</h4>
<p>These optimizations are intended to be done after transforming the program into a special form called static single assignment (see <a href="/wiki/SSA_%28compilers%29.html" title="SSA (compilers)">SSA</a> form), in which every variable is assigned in only one place. Although some function without SSA, they are most effective with SSA. Many optimizations listed in other sections also benefit with no special changes, such as register allocation.</p>
<p><b><a href="/wiki/Global_value_numbering.html" title="Global value numbering">global value numbering</a></b>: GVN eliminates redundancy by constructing a <a  class="new" title="Value graph (compilers)">value graph</a> of the program, and then determining which values are computed by equivalent expressions. GVN is able to identify some redundancy that <a href="/wiki/Common_subexpression_elimination.html" title="Common subexpression elimination">common subexpression elimination</a> cannot, and vice versa.</p>
<p><b><a href="/wiki/Sparse_conditional_constant_propagation.html" title="Sparse conditional constant propagation">sparse conditional constant propagation</a></b>: Effectively equivalent to iteratively performing <a href="/wiki/Constant_propagation.html" title="Constant propagation">constant propagation</a>, <a href="/wiki/Constant_folding.html" title="Constant folding">constant folding</a>, and <a href="/wiki/Dead_code_elimination.html" title="Dead code elimination">dead code elimination</a> until there is no change, but is much more efficient. This optimization symbolically executes the program, simultaneously propagating constant values and eliminating portions of the <a href="/wiki/Control_flow_graph.html" title="Control flow graph">control flow graph</a> that this makes unreachable.</p>
<hr />
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Code generator optimizations">edit</a>]</div>
<p><a name="Code_generator_optimizations" id="Code_generator_optimizations"></a></p>
<h4>Code generator optimizations</h4>
<p><b><a href="/wiki/Register_allocation.html" title="Register allocation">register allocation</a></b>: The most frequently used variables should be kept in processor registers for fastest access. To find which variables to put in registers an interference-graph is created. Each variable is a vertex and when two variables are used at the same time (have an intersecting liverange) they have an edge between them. This graph is colored using for example <a href="/wiki/Chaitin%27s_algorithm.html" title="Chaitin's algorithm">Chaitin's algorithm</a> using the same number of colors as there are registers. If the coloring fails one variable is "spilled" to memory and the coloring is retried.</p>
<p><b><a href="/wiki/Instruction_selection.html" title="Instruction selection">instruction selection</a></b>: Most architectures, particularly <a href="/wiki/CISC.html" title="CISC">CISC</a> architectures and those with many <a href="/wiki/Addressing_mode.html" title="Addressing mode">addressing modes</a>, offer several different ways of performing a particular operation, using entirely different sequences of instructions. The job of the instruction selector is to do a good job overall of choosing which instructions to implement which operators in the low-level <a href="/wiki/Intermediate_representation.html" title="Intermediate representation">intermediate representation</a> with. For example, on many processors in the <a href="/wiki/68000_family.html" title="68000 family">68000 family</a>, complex addressing modes can be used in statements like "lea 25(a1,d5*4), a0", allowing a single instruction to perform a significant amount of arithmetic with less storage.</p>
<p><b><a href="/wiki/Instruction_scheduling.html" title="Instruction scheduling">instruction scheduling</a></b>&#160;: Instruction scheduling is an important optimization for modern <a href="/wiki/Instruction_pipeline.html" title="Instruction pipeline">pipelined</a> processors, which avoids stalls or bubbles in the pipeline by clustering instructions with no dependencies together, while being careful to preserve the original semantics.</p>
<p><b><a href="/wiki/Rematerialization.html" title="Rematerialization">rematerialization</a></b>&#160;: Rematerialization recalculates a value instead of loading it from memory, preventing a memory access. This is performed in tandem with register allocation to avoid spills.</p>
<p><b>reordering computations</b>:Based on <a href="/wiki/Integer_linear_programming.html" title="Integer linear programming">integer linear programming</a>, restructuring compilers enhance data locality and expose more parallelism by reordering computations.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Functional language optimizations">edit</a>]</div>
<p><a name="Functional_language_optimizations" id="Functional_language_optimizations"></a></p>
<h4>Functional language optimizations</h4>
<p>Although many of these also apply to non-functional languages, they either originate in, are most easily implemented in, or are particularly critical in <a href="/wiki/Functional_language.html" title="Functional language">functional languages</a> such as <a href="/wiki/Lisp_programming_language.html" title="Lisp programming language">Lisp</a> and <a href="/wiki/ML_programming_language.html" title="ML programming language">ML</a>.</p>
<dl>
<dt><i>removing <a href="/wiki/Recursion.html" title="Recursion">recursion</a></i>&#160;</dt>
<dd>Recursion is often expensive, as a function call consumes stack space and involves some overhead related to parameter passing and flushing the instruction cache. <a href="/wiki/Tail_recursion.html" title="Tail recursion">Tail recursive</a> algorithms can be converted to <a href="/wiki/Iteration.html" title="Iteration">iteration</a>, which does not have call overhead and uses a constant amount of stack space, through a process called tail recursion elimination.</dd>
</dl>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Other optimizations">edit</a>]</div>
<p><a name="Other_optimizations" id="Other_optimizations"></a></p>
<h4>Other optimizations</h4>
<p><i>Please help separate and categorize these further and create detailed pages for them, especially the more complex ones, or link to one where one exists.</i></p>
<dl>
<dt><a href="/wiki/Bounds-checking_elimination.html" title="Bounds-checking elimination">bounds-checking elimination</a>&#160;</dt>
<dd>Several modern languages, most notably <a href="/wiki/Java_programming_language.html" title="Java programming language">Java</a>, enforce bounds-checking of all array accesses. This is a severe performance bottleneck on certain applications such as scientific code. Bounds-checking elimination allows the compiler to safely remove bounds-checking in many situations where it can determine that the index must fall within valid bounds, for example if it is a simple loop variable.</dd>
</dl>
<dl>
<dt><i>Branch offset optimization (machine independent)</i></dt>
<dd>Choose the shortest branch displacement that reaches target</dd>
</dl>
<dl>
<dt><i>code-block reordering</i></dt>
<dd>Code-block reordering alters the order of the <a href="/wiki/Basic_block.html" title="Basic block">basic blocks</a> in a program in order to reduce conditional branches and improve <a href="/wiki/Locality_of_reference.html" title="Locality of reference">locality of reference</a>.</dd>
</dl>
<dl>
<dt><a href="/wiki/Dead_code_elimination.html" title="Dead code elimination">dead code elimination</a></dt>
<dd>Removes instructions that will not affect the behaviour of the program, for example definitions which have no uses, called <a href="/wiki/Dead_code.html" title="Dead code">dead code</a>. This reduces code size and eliminates unnecessary computation.</dd>
</dl>
<dl>
<dt><i>factoring out of invariants</i>&#160;</dt>
<dd>If an expression is carried out both when a condition is met and otherwise, it can be written just once outside of the conditional statement. Similarly, if certain types of expressions (e.g. the assignment of a constant into a variable) appear inside a loop, they can be moved out of it because their effect will be the same no matter if they're executed many times or just once. Also known as total redundancy elimination. A more powerful optimization is <a href="/wiki/Partial_redundancy_elimination.html" title="Partial redundancy elimination">Partial redundancy elimination</a> (PRE).</dd>
</dl>
<dl>
<dt><a href="/wiki/Inline_expansion.html" title="Inline expansion">inline expansion</a>&#160;</dt>
<dd>When some code invokes a <a href="/wiki/Procedure.html" title="Procedure">procedure</a>, it is possible to directly insert the body of the procedure inside the calling code rather than transferring control to it. This saves the overhead related to procedure calls, as well as providing great opportunity for many different parameter-specific optimizations, but comes at the cost of space; the procedure body is duplicated each time the procedure is called inline. Generally, inlining is useful in performance-critical code that makes a large number of calls to small procedures.</dd>
</dl>
<dl>
<dt><a href="/wiki/Jump_threading.html" title="Jump threading">jump threading</a></dt>
<dd>In this pass, conditional jumps in the code that branch to identical or inverse tests are detected, and can be "threaded" through a second conditional test.</dd>
</dl>
<dl>
<dt><a href="/wiki/Strength_reduction.html" title="Strength reduction">strength reduction</a>&#160;</dt>
<dd>A general term encompassing optimizations that replace complex or difficult or expensive operations with simpler ones. <a href="/wiki/Induction_variable_analysis.html" title="Induction variable analysis">Induction variable analysis</a> can accomplish this with variables inside a loop which depend on the loop variable. Several <a href="/wiki/Peephole_optimization.html" title="Peephole optimization">peephole optimizations</a> also fall into this category, such as replacing division by a constant with multiplication by its reciprocal, converting multiplies into a series of bit-shifts and adds, and replacing large instructions with equivalent smaller ones that load more quickly.</dd>
</dl>
<dl>
<dt><i>reduction of cache collisions</i>&#160;</dt>
<dd>(e.g. by disrupting alignment within a page)</dd>
</dl>
<dl>
<dt><i>Stack height reduction</i></dt>
<dd>Rearrange expression tree to minimize resources needed for expression evaluation.</dd>
</dl>
<dl>
<dt><i>test reordering</i>&#160;</dt>
<dd>If we have two tests that are the condition for something, we can first deal with the simpler tests (e.g. comparing a variable to something) and only then with the complex tests (e.g. those that require a function call). This technique complements <a href="/wiki/Lazy_evaluation.html" title="Lazy evaluation">lazy evaluation</a>, but can be used only when the tests are not dependent on one another. <a href="/wiki/Minimal_evaluation.html" title="Minimal evaluation">Short-circuiting</a> semantics can make this difficult.</dd>
</dl>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Interprocedural optimizations">edit</a>]</div>
<p><a name="Interprocedural_optimizations" id="Interprocedural_optimizations"></a></p>
<h3>Interprocedural optimizations</h3>
<p>Inter Procedural optimization works on the entire program, across procedure and file boundaries. It works tightly with intraprocedural counterparts, carried out with the cooperation of a local part and global part. Typical interprocedural optimizations are&#160;: procedure <a href="/wiki/Inlining.html" title="Inlining">inlining</a>, interprocedural <a href="/wiki/Dead_code_elimination.html" title="Dead code elimination">dead code elimination</a>, interprocedural <a href="/wiki/Constant_propagation.html" title="Constant propagation">constant propagation</a>, <a  class="new" title="Procedure reordering">procedure reordering</a>. As usual, interprocedural analysis is needed before actual optimizations, such as interprocedural <a href="/wiki/Alias_analysis.html" title="Alias analysis">alias analysis</a>, <a href="/wiki/Array_access_analysis.html" title="Array access analysis">array access analysis</a>, construction of callgraph etc.</p>
<p>The existence of interprocedural analysis and optimization is common in modern commercial compilers from <a href="/wiki/Silicon_Graphics.html" title="Silicon Graphics">SGI</a>, <a href="/wiki/Intel.html" title="Intel">Intel</a>, <a href="/wiki/Microsoft.html" title="Microsoft">Microsoft</a>, and <a href="/wiki/Sun_Microsystems.html" title="Sun Microsystems">Sun Microsystems</a>. For a long time the open source <a href="/wiki/GNU_Compiler_Collection.html" title="GNU Compiler Collection">GCC</a> was criticized for a lack of powerful interprocedural analysis and optimizations. But now things are changing. Another good open source compiler with full analysis and optimization infrastructure is <a href="/wiki/Open64.html" title="Open64">Open64</a>, which is used by many organizations for research or even commercial purposes.</p>
<p>Due to the extra time and space requirement from compiler analysis and optimizations, most compilers choose to turn them off by default. Users must use compilation options to explicitly tell the compiler to enable some of them. Typical compilation options are -O2, -O3, -ipa/ipo, -lno etc.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Problems with optimization">edit</a>]</div>
<p><a name="Problems_with_optimization" id="Problems_with_optimization"></a></p>
<h2>Problems with optimization</h2>
<p>Early in the history of compilers, compiler optimizations were not as good as hand-written ones. As compiler technologies have improved, good compilers can often generate better code than human programmers â€” and good post pass optimizers can improve highly hand-optimized code even further. For <a href="/wiki/RISC.html" title="RISC">RISC</a> CPU architectures, and even more so for <a href="/wiki/VLIW.html" title="VLIW">VLIW</a> hardware, compiler optimization is the key for obtaining efficient code, because RISC instruction sets are so compact that it is hard for a human to manually schedule or combine small instructions to get efficient results. Indeed, these architectures were designed to rely on compiler writers for adequate performance.</p>
<p>However, optimizing compilers are by no means perfect. There is no way that a compiler can guarantee that, for all program source code, the fastest (or smallest) possible equivalent compiled program is output; such a compiler is fundamentally impossible because it would solve the <a href="/wiki/Halting_problem.html" title="Halting problem">halting problem</a>. Additionally, there are a number of other more practical issues with optimizing compiler technology:</p>
<ul>
<li>Usually, an optimizing compiler only performs low-level, localized changes to small sets of operations. In other words, high-level inefficiency in the source program (such as an inefficient algorithm) remains unchanged.</li>
</ul>
<ul>
<li>Modern third-party compilers usually have to support several objectives. In so doing, these compilers are a 'jack of all trades' yet master of none.</li>
</ul>
<ul>
<li>A compiler typically only deals with a small part of an entire program at a time, at most a module at a time and usually only a procedure; the result is that it is unable to consider at least some important contextual information.</li>
</ul>
<ul>
<li>The overhead of compiler optimization. Any extra work takes time, whole-program optimization (interprocedural optimization) is very costly.</li>
</ul>
<ul>
<li>The interaction of compiler optimization phases: what combination of optimization phases are optimal, in what order and how many times?</li>
</ul>
<p>Work to improve optimization technology continues. One approach is the use of so-called "post pass" optimizers. These tools take the executable output by an "optimizing" compiler and optimize it even further. As opposed to compilers which optimize intermediate representations of programs, post pass optimizers work on the <a href="/wiki/Assembly_language.html" title="Assembly language">assembly language</a> level. Post pass compilers are also limited by this, however, in that much of the information found in the original source code is lost.</p>
<p>As processor performance continues to improve at a rapid pace while memory bandwidth improves more slowly, optimizations that reduce memory bandwidth (even at the cost of making the processor execute "extra" instructions) will become more useful. Examples of this mentioned above include <a href="/wiki/Loop_nest_optimization.html" title="Loop nest optimization">loop nest optimization</a> and <a href="/wiki/Rematerialization.html" title="Rematerialization">rematerialization</a>.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: List of compiler optimizations">edit</a>]</div>
<p><a name="List_of_compiler_optimizations" id="List_of_compiler_optimizations"></a></p>
<h2>List of compiler optimizations</h2>
<ul>
<li><a href="/wiki/Alias_analysis.html" title="Alias analysis">alias analysis</a></li>
<li><a href="/wiki/Array_access_analysis.html" title="Array access analysis">array access analysis</a></li>
<li><a href="/wiki/Constant_folding.html" title="Constant folding">constant folding</a></li>
<li>algebraic simplifications:</li>
<li>value numbering</li>
<li>copy propagation:</li>
<li><a href="/wiki/Constant_propagation.html" title="Constant propagation">constant propagation</a></li>
<li><a href="/wiki/Common_subexpression_elimination.html" title="Common subexpression elimination">common subexpression elimination</a> (CSE)</li>
<li><a href="/wiki/Partial_redundancy_elimination.html" title="Partial redundancy elimination">partial redundancy elimination</a></li>
<li><a href="/wiki/Dead_code_elimination.html" title="Dead code elimination">dead code elimination</a></li>
<li>induction variable elimination, <a href="/wiki/Strength_reduction.html" title="Strength reduction">strength reduction</a></li>
<li>loop optimizations
<ul>
<li>loop invariant code motion</li>
<li>loop unrolling</li>
<li>more at <a href="/wiki/Loop_optimization.html" title="Loop optimization">loop optimizations</a></li>
</ul>
</li>
<li><a href="/wiki/Software_pipelining.html" title="Software pipelining">software pipelining</a></li>
<li>inlining</li>
<li>code generator
<ul>
<li><a href="/wiki/Register_allocation.html" title="Register allocation">register allocation</a>: local and global</li>
<li><a href="/wiki/Instruction_scheduling.html" title="Instruction scheduling">instruction scheduling</a></li>
<li>branch optimizations</li>
<li>tail merging and cross jumping</li>
<li>machine idioms and instruction combining</li>
</ul>
</li>
</ul>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: External links">edit</a>]</div>
<p><a name="External_links" id="External_links"></a></p>
<h2>External links</h2>
<ul>
<li><a  class="external text" title="http://www.nullstone.com/htmls/category.htm">NULLSTONE Optimization Categories</a> - major compiler optimization categories.</li>
<li><a  class="external text" title="http://www.redhat.com/en_us/USA/home/gnupro/technicaldetails/gccoptimization/">GCC optimizations</a> - a <a href="/wiki/Red_Hat.html" title="Red Hat">Red Hat</a> page discussing some of the optimizations implemented by GCC.</li>
</ul>


<!-- Saved in parser cache with key enwiki:pcache:idhash:40355-0!1!0!default!!en!2 and timestamp 20060908175636 -->
<div class="printfooter">
Retrieved from "<a </div>
			<div id="catlinks"><p class='catlinks'><a  title="Special:Categories">Categories</a>: <span dir='ltr'><a  title="Category:Compiler optimizations">Compiler optimizations</a></span> | <span dir='ltr'><a  title="Category:Programming language implementation">Programming language implementation</a></span></p></div>			<!-- end content -->
			<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<ul>
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Compiler_optimization.html">Article</a></li>
				 <li id="ca-talk"><a >Discussion</a></li>
				 <li id="ca-edit"><a >Edit this page</a></li>
				 <li id="ca-history"><a >History</a></li>
		</ul>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a >Sign in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(/images/wiki-en.png);" href="/wiki/Main_Page.html" title="Main Page"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage"><a href="/wiki/Main_Page.html">Main Page</a></li>
				<li id="n-portal"><a >Community Portal</a></li>
				<li id="n-Featured-articles"><a >Featured articles</a></li>
				<li id="n-currentevents"><a >Current events</a></li>
				<li id="n-recentchanges"><a >Recent changes</a></li>
				<li id="n-randompage"><a >Random article</a></li>
				<li id="n-help"><a >Help</a></li>
				<li id="n-contact"><a >Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a >Donations</a></li>
			</ul>
		</div>
	</div>
		<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/wiki/Special:Search" id="searchform"><div>
				<input id="searchInput" name="search" type="text" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" value="Search" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a >What links here</a></li>
				<li id="t-recentchangeslinked"><a >Related changes</a></li>
<li id="t-upload"><a >Upload file</a></li>
<li id="t-specialpages"><a >Special pages</a></li>
				<li id="t-print"><a >Printable version</a></li>				<li id="t-permalink"><a >Permanent link</a></li><li id="t-cite"><a >Cite this article</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>In other languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-he"><a >×¢×‘×¨×™×ª</a></li>
				<li class="interwiki-pl"><a >Polski</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a ><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="MediaWiki" /></a></div>
				<div id="f-copyrightico"><a ><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
				<li id="lastmod"> This page was last modified 08:47, 4 September 2006.</li>
				<li id="copyright">All text is available under the terms of the <a class='internal'  title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal'  title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the Wikimedia Foundation, Inc.<br /></li>
				<li id="privacy"><a  title="wikimedia:Privacy policy">Privacy policy</a></li>
				<li id="about"><a  title="Wikipedia:About">About Wikipedia</a></li>
				<li id="disclaimer"><a  title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
		
	
		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
</div>
<!-- Served by srv70 in 0.181 secs. --></body></html>
