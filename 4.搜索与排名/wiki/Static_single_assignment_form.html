<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="keywords" content="Static single assignment form,1980s,Assembly language,Backend,Byte-code,C programming language,Compiler,Compiler optimization,Constant propagation,Continuation passing style,Control flow graph" />
<link rel="shortcut icon"  />
<link rel="search" type="application/opensearchdescription+xml"  />
<link rel="copyright"  />
		<title>Static single assignment form - Wikipedia, the free encyclopedia</title>
		<style type="text/css" media="screen,projection">/*<![CDATA[*/ @import "/skins-1.5/monobook/main.css?9"; /*]]>*/</style>
		<link rel="stylesheet" type="text/css" media="print"  />
		<!--[if lt IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE50Fixes.css";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE55Fixes.css";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/skins-1.5/monobook/IE60Fixes.css";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/skins-1.5/monobook/IE70Fixes.css?1";</style><![endif]-->
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
		
		<script type= "text/javascript">
			var skin = "monobook";
			var stylepath = "/skins-1.5";

			var wgArticlePath = "/wiki/$1";
			var wgScriptPath = "/w";
			var wgServer = "http://en.wikipedia.org";
                        
			var wgCanonicalNamespace = "";
			var wgNamespaceNumber = 0;
			var wgPageName = "Static_single_assignment_form";
			var wgTitle = "Static single assignment form";
			var wgArticleId = 373371;
			var wgIsArticle = true;
                        
			var wgUserName = null;
			var wgUserLanguage = "en";
			var wgContentLanguage = "en";
		</script>
		                
		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?1"><!-- wikibits js --></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js"><!-- site js --></script>
		<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Common.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=MediaWiki:Monobook.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=-&action=raw&gen=css&maxage=2678400";
/*]]>*/</style>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js"></script>
	</head>
<body  class="mediawiki ns-0 ltr">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><div style="text-align:right; font-size:80%">Your <b><a  class="extiw" title="wikimedia:Fundraising">continued donations</a></b> keep Wikipedia running!&nbsp;&nbsp;&nbsp;&nbsp;</div>
</div>		<h1 class="firstHeading">Static single assignment form</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a >navigation</a>, <a >search</a></div>			<!-- start content -->
			<p>In <a href="/wiki/Compiler.html" title="Compiler">compiler</a> design, <b>static single assignment form</b> (often abbreviated as <b>SSA form</b> or <b>SSA</b>) is an <a href="/wiki/Intermediate_representation.html" title="Intermediate representation">intermediate representation</a> (IR) in which every variable is assigned exactly once. Existing variables in the original IR are split into <i>versions</i>, new variables typically indicated by the original name with a subscript, so that every definition gets its own version. In SSA form, <a href="/wiki/Use-define_chain.html" title="Use-define chain">use-def chains</a> are explicit and each contains a single element.</p>
<p>SSA was developed by <a  class="new" title="Ron Cytron">Ron Cytron</a>, <a  class="new" title="Jeanne Ferrante">Jeanne Ferrante</a>, <a  class="new" title="Barry Rosen">Barry Rosen</a>, <a href="/wiki/Mark_Wegman.html" title="Mark Wegman">Mark Wegman</a>, and <a  class="new" title="Ken Zadeck">Ken Zadeck</a>, researchers at <a href="/wiki/International_Business_Machines.html" title="International Business Machines">IBM</a> in the <a href="/wiki/1980s.html" title="1980s">1980s</a>.</p>
<p>In <a href="/wiki/Functional_language.html" title="Functional language">functional language</a> compilers, such as those for <a href="/wiki/Scheme_programming_language.html" title="Scheme programming language">Scheme</a>, <a href="/wiki/ML_programming_language.html" title="ML programming language">ML</a> and <a href="/wiki/Haskell_programming_language.html" title="Haskell programming language">Haskell</a>, <a href="/wiki/Continuation_passing_style.html" title="Continuation passing style">continuation passing style</a> (CPS) is generally used where one might expect to find SSA in a compiler for <a href="/wiki/Fortran.html" title="Fortran">Fortran</a> or <a href="/wiki/C_programming_language.html" title="C programming language">C</a>.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a ><span class="tocnumber">1</span> <span class="toctext">Benefits of SSA</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">2</span> <span class="toctext">Converting to SSA</span></a>
<ul>
<li class="toclevel-2"><a ><span class="tocnumber">2.1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-2"><a ><span class="tocnumber">2.2</span> <span class="toctext">Computing minimal SSA using dominance frontiers</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a ><span class="tocnumber">3</span> <span class="toctext">Variations that Reduce the Number of Φ Functions</span></a>
<ul>
<li class="toclevel-2"><a ><span class="tocnumber">3.1</span> <span class="toctext">Semi-Pruned SSA</span></a></li>
<li class="toclevel-2"><a ><span class="tocnumber">3.2</span> <span class="toctext">Pruned SSA</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a ><span class="tocnumber">4</span> <span class="toctext">Converting out of SSA form</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">5</span> <span class="toctext">Extensions to SSA Form</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">6</span> <span class="toctext">Compilers using SSA form</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">7</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">8</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">9</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<p><script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script></p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Benefits of SSA">edit</a>]</div>
<p><a name="Benefits_of_SSA" id="Benefits_of_SSA"></a></p>
<h2>Benefits of SSA</h2>
<p>The primary usefulness of SSA comes from how it simultaneously simplifies and improves the results of a variety of <a href="/wiki/Compiler_optimization.html" title="Compiler optimization">compiler optimizations</a>, by simplifying the properties of variables. For example, consider this piece of code:</p>
<pre>
 y := 1
 y := 2
 x := y
</pre>
<p>As humans, we can see that the first assignment is not necessary, and that the value of <code>y</code> being used in the third line comes from the second assignment of <code>y</code>. A program would have to perform <a href="/wiki/Reaching_definition.html" title="Reaching definition">reaching definition analysis</a> to determine this. But if the program is in SSA form, both of these are immediate:</p>
<pre>
 y<sub>1</sub> := 1
 y<sub>2</sub> := 2
 x<sub>1</sub> := y<sub>2</sub>
</pre>
<p><a href="/wiki/Compiler_optimization.html" title="Compiler optimization">Compiler optimization</a> algorithms which are either enabled or strongly enhanced by the use of SSA include:</p>
<ul>
<li><a href="/wiki/Constant_propagation.html" title="Constant propagation">constant propagation</a></li>
<li><a href="/wiki/Sparse_conditional_constant_propagation.html" title="Sparse conditional constant propagation">sparse conditional constant propagation</a></li>
<li><a href="/wiki/Dead_code_elimination.html" title="Dead code elimination">dead code elimination</a></li>
<li><a href="/wiki/Global_value_numbering.html" title="Global value numbering">global value numbering</a></li>
<li><a href="/wiki/Partial_redundancy_elimination.html" title="Partial redundancy elimination">partial redundancy elimination</a></li>
<li><a href="/wiki/Strength_reduction.html" title="Strength reduction">strength reduction</a></li>
<li><a href="/wiki/Register_allocation.html" title="Register allocation">register allocation</a></li>
</ul>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Converting to SSA">edit</a>]</div>
<p><a name="Converting_to_SSA" id="Converting_to_SSA"></a></p>
<h2>Converting to SSA</h2>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Introduction">edit</a>]</div>
<p><a name="Introduction" id="Introduction"></a></p>
<h3>Introduction</h3>
<p>Converting ordinary code into SSA form is primarily a simple matter of replacing the target of each assignment with a new variable, and replacing each use of a variable with the "version" of the variable <a href="/wiki/Reaching_definition.html" title="Reaching definition">reaching</a> that point. For example, consider the following <a href="/wiki/Control_flow_graph.html" title="Control flow graph">control flow graph</a>:</p>
<center>
<p><a  class="image" title="An example control flow graph, before conversion to SSA"><img src="http://upload.wikimedia.org/wikipedia/en/7/73/SSA_example1.1.png" alt="An example control flow graph, before conversion to SSA" width="200" height="290" longdesc="/wiki/Image:SSA_example1.1.png" /></a></p>
</center>
<p>Notice that we could change the name on the left side of "x <img class='tex' src="http://upload.wikimedia.org/math/a/6/4/a6465c0244621c63e7e1e96eb55aad7a.png" alt="\leftarrow" /> x - 3", and change the following uses of <var>x</var> to use that new name, and the program would still do the same thing. We exploit this in SSA by creating two new variables, <var>x</var><sub>1</sub> and <var>x</var><sub>2</sub>, each of which is assigned only once. We likewise give distinguishing subscripts to all the other variables, and we get this:</p>
<center>
<p><a  class="image" title="An example control flow graph, partially converted to SSA"><img src="http://upload.wikimedia.org/wikipedia/en/f/f7/SSA_example1.2.png" alt="An example control flow graph, partially converted to SSA" width="200" height="290" longdesc="/wiki/Image:SSA_example1.2.png" /></a></p>
</center>
<p>We've figured out which definition each use is referring to, except for one thing: the uses of <var>y</var> in the bottom block could be referring to <i>either</i> <var>y</var><sub>1</sub> or <var>y</var><sub>2</sub>, depending on which way the control flow came from. So how do we know which one to use? The answer is that we add a special statement, called a <i>Φ (Phi) function</i>, to the beginning of the last block. This statement will generate a new definition of <var>y</var>, <var>y</var><sub>3</sub>, by "choosing" either <var>y</var><sub>1</sub> or <var>y</var><sub>2</sub>, depending on which arrow control arrived from:</p>
<center>
<p><a  class="image" title="An example control flow graph, fully converted to SSA"><img src="http://upload.wikimedia.org/wikipedia/en/8/84/SSA_example1.3.png" alt="An example control flow graph, fully converted to SSA" width="200" height="298" longdesc="/wiki/Image:SSA_example1.3.png" /></a></p>
</center>
<p>Now, the uses of <var>y</var> in the last block can simply use <var>y</var><sub>3</sub>, and they'll obtain the correct value either way. You might ask at this point, do we need to add a Φ function for <var>x</var> too? The answer is no; only one version of <var>x</var>, namely <var>x</var><sub>2</sub> is reaching this place, so there's no problem. A more general question along the same lines is, given an arbitrary control flow graph, how can I tell where to insert Φ functions, and for what variables? This is a difficult question, but one that has an efficient solution that can be computed using a concept called <i>dominance frontiers</i>. Note: the Φ functions are not actually implemented; instead, they're just markers for the compiler to place the value of all the variables grouped together by the Φ function, in the same location in memory (or same register).</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Computing minimal SSA using dominance frontiers">edit</a>]</div>
<p><a name="Computing_minimal_SSA_using_dominance_frontiers" id="Computing_minimal_SSA_using_dominance_frontiers"></a></p>
<h3>Computing minimal SSA using dominance frontiers</h3>
<p>First, we need the concept of a <a href="/wiki/Dominator.html" title="Dominator"><i>dominator</i></a>: we say that a node A <i>strictly dominates</i> a different node B in the control flow graph if it's impossible to reach B without passing through A first. This is useful, because if we ever reach B we know that any code in A has run. We say that A <i>dominates</i> B if either A strictly dominates B or A = B.</p>
<p>Now we can define the <a href="/wiki/Dominator.html" title="Dominator"><i>dominance frontier</i></a>: the dominance frontier of a node A is the set of nodes that A does <i>not</i> strictly dominate, but does dominate some immediate predecessor of. From A's point of view, these are the nodes at which other control paths that don't go through A make their earliest appearance.</p>
<p><br />
Dominance frontiers capture the precise places at which we need Φ functions: if the node A defines a certain variable, then that definition and that definition alone will reach every node A dominates. Only when we leave these nodes and enter the dominance frontier must we account for other flows bringing in other definitions of the same variable. Moreover, no other Φ functions are needed in the control flow graph to deal with A's definitions, and we can do with no less.</p>
<p><br />
One algorithm for computing the dominance frontier set is:</p>
<pre>
<b>for each</b> node b
    <b>if</b> the number of predecessors of b ≥ 2
        <b>for each</b> p <b>in</b> predecessors of b
            runner := p
            <b>while</b> runner ≠ idom(b)
                add b to runner’s dominance frontier set
                runner := idom(runner)
</pre>
<p>Note: in the code above, a predecessor is any node from which control is transferred to this node, and idom(n) is the immediate dominator of node n.</p>
<p>There is an efficient algorithm for finding dominance frontiers of each node. This algorithm was originally described in the paper "Efficiently computing static single assignment form and the control dependence graph", by R. Cytron, J. Ferrante, B. Rosen, M. Wegman and F. Zadeck, <i>ACM Trans. on Programming Languages and Systems</i> 13(4) 1991 pp.451–490. Also useful is chapter 19 of the book "Modern compiler implementation in Java" by Andrew Appel (Cambridge University Press, 2002). See the paper for more details.</p>
<p>Keith D. Cooper, Timothy J. Harvey, and Ken Kennedy of <a href="/wiki/Rice_University.html" title="Rice University">Rice University</a> describe an algorithm in their paper titled <a  class="external text" title="http://www.hipersoft.rice.edu/grads/publications/dom14.pdf"><i>A Simple, Fast Dominance Algorithm</i></a>. The algorithm uses well engineered data structures to improve performance.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Variations that Reduce the Number of Φ Functions">edit</a>]</div>
<p><a name="Variations_that_Reduce_the_Number_of_.CE.A6_Functions" id="Variations_that_Reduce_the_Number_of_.CE.A6_Functions"></a></p>
<h2>Variations that Reduce the Number of Φ Functions</h2>
<p>"Minimal" SSA inserts the minimal number of Φ functions required to ensure that each name is assigned a value exactly once and that each reference (use) of a name in the original program can still refer to a unique name. (The latter requirement is needed to ensure that the compiler can write down a name for each operand in each operation.)</p>
<p>However, some of these Φ functions could be <i><a href="/wiki/Dead_code_elimination.html" title="Dead code elimination">dead</a></i>. For this reason, minimal SSA does not necessarily produce the fewest number of Φ functions that are needed by a specific procedure. This observation has led to other variants on SSA that use additional analysis of the code to reduce the number of Φ functions that are created. Two examples are Semi-pruned SSA and Pruned SSA.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Semi-Pruned SSA">edit</a>]</div>
<p><a name="Semi-Pruned_SSA" id="Semi-Pruned_SSA"></a></p>
<h3>Semi-Pruned SSA</h3>
<p>Semi-Pruned SSA builds on a simple observation: Φ functions are only needed for variables that are live in more than one basic block. To build semi-pruned SSA, the compiler makes a preliminary pass over the code, computing the number of blocks in which each name appears. This computation uses the original names in the code as input to the SSA construction. The compiler then omits from the minimal SSA construction all names that appear in just one block. Reducing the domain of the construction in this way shrinks several of the data structures and produces a variant of SSA with fewer Φ functions.</p>
<p>Note that this same trick, reducing the name space to include only names that are referenced in multiple blocks, can be applied to many other problems in optimization. Most data-flow analyses will benefit from reducing the problem domain in this fashion. While the idea was applied to SSA form by Preston Briggs, it hearkens back to the hierarchical approach used by Fran Allen et al. in IBM's Experimental Compiling System (ECS) in the 1970s.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Pruned SSA">edit</a>]</div>
<p><a name="Pruned_SSA" id="Pruned_SSA"></a></p>
<h3>Pruned SSA</h3>
<p>Pruned SSA builds on a stronger observation: Φ functions are only needed for variables that are "live" after the Φ function. (Here, "live" means that the value is used along some path that begins at the Φ function in question.) If a variable is not live, the result of the Φ function cannot be used and the assignment by the Φ function is dead. Pruned SSA removes strictly more Φ functions than semi-pruned SSA. However, computing live variables takes more time than counting the number of blocks where each variable is referenced, so the construction is more expensive than either the minimal or the semi-pruned construction.</p>
<p>To construct pruned SSA form, the compiler computes <a href="/wiki/Live_variable_analysis.html" title="Live variable analysis">live variable information</a> (using <a href="/wiki/Data_flow_analysis.html" title="Data flow analysis">data flow analysis</a>) for every name in the input program. The compiler could then use the minimal SSA construction with an added test before it inserts each Φ function, to only insert the Φ function if the original name is live. In practice, compilers often use <i>bit vectors</i> for their data structures: since dominance frontiers and live variables are no exception, the compiler will more likely determine the pruned insertion points, as the intersection of the dominance frontiers of blocks defining the name, and the basic blocks at whose beginning the name is live.</p>
<p>Another possibility is to treat pruning as a <a href="/wiki/Dead_code_elimination.html" title="Dead code elimination">dead code elimination</a> problem. Then, a Φ function is live only if any use in the input program will be rewritten to it, or if it will be used as an argument in another Φ function. When entering SSA form, each use is rewritten to the nearest definition that dominates it. A Φ function will then be considered live as long as it is the nearest definition that dominates at least one use, or at least one argument of a live Φ.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Converting out of SSA form">edit</a>]</div>
<p><a name="Converting_out_of_SSA_form" id="Converting_out_of_SSA_form"></a></p>
<h2>Converting out of SSA form</h2>
<p>As SSA form is no longer useful for direct execution, it is frequently used "on top of" another IR with which it remains in direct correspondence. This can be accomplished by "constructing" SSA as a set of functions which map between parts of the existing IR (basic blocks, instructions, operands, <i>etc.</i>) and its SSA counterpart. When the SSA form is no longer needed, these mapping functions may be discarded, leaving only the now-optimized IR.</p>
<p>If one absolutely needed to execute a program in SSA form, Φ functions could be moved to the bottom of each of their predecessor blocks and then turned into simple move operations.</p>
<p><i>Simple copy insertion, algorithms to reduce copies, etc. If overlapping lifetimes are allowed simply dropping the subscripts doesn't work. Pure SSA form doesn't really use subscripts anyway.</i></p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Extensions to SSA Form">edit</a>]</div>
<p><a name="Extensions_to_SSA_Form" id="Extensions_to_SSA_Form"></a></p>
<h2>Extensions to SSA Form</h2>
<p>Extensions to SSA form can be divided into two categories.</p>
<p><i>Renaming scheme</i> extensions alter the renaming criterion. Recall that SSA form renames each variable when it is assigned a value. Alternative schemes include static single use form (which renames each variable at each statement when it is used) and static single information form (which renames each variable when it is assigned a value, and in each conditional context in which that variable is used).</p>
<p><i>Feature-specific</i> extensions retain the single assignment property for variables, but incorporate new semantics to model additional features. Some feature-specific extensions model high-level programming language features like arrays, objects and aliased pointers. Other feature-specific extensions model low-level architectural features like speculation and predication.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Compilers using SSA form">edit</a>]</div>
<p><a name="Compilers_using_SSA_form" id="Compilers_using_SSA_form"></a></p>
<h2>Compilers using SSA form</h2>
<p>SSA form is a relatively recent development in the compiler community. As such, many older compilers only use SSA form for some part of the compilation or optimization process, but most do not rely on it. Examples of compilers that rely heavily on SSA form include:</p>
<ul>
<li>The <a href="/wiki/LLVM.html" title="LLVM">LLVM</a> Compiler Infrastructure uses SSA form for all scalar register values (everything except memory) in its primary code representation. SSA form is only eliminated once register allocation occurs, late in the compile process (often at link time).</li>
</ul>
<ul>
<li>The open source SGI compiler <a  class="external text" title="http://ipf-orc.sourceforge.net/">ORC</a> uses SSA form in its global scalar optimizer, though the code is brought into SSA form before and taken out of SSA form afterwards. ORC uses extensions to SSA form to represent memory in SSA form as well as scalar values.</li>
</ul>
<ul>
<li>As of version 4 (released in April 2005), the <a href="/wiki/GNU_Compiler_Collection.html" title="GNU Compiler Collection">GNU Compiler Collection</a> makes extensive use of SSA. The <a href="/wiki/Frontend.html" title="Frontend">frontends</a> generate <a href="/wiki/GENERIC.html" title="GENERIC">GENERIC</a> code which is then converted into SSA form by the "<a  class="new" title="Gimplifier">gimplifier</a>" and optimized by the "<a  class="new" title="Middle-end">middle-end</a>". The <a href="/wiki/Backend.html" title="Backend">backend</a> eventually translates the optimized intermediate code into <a href="/wiki/Register_Transfer_Language.html" title="Register Transfer Language">RTL</a>, executes some more low-level optimizations and finally turns RTL into <a href="/wiki/Assembly_language.html" title="Assembly language">assembly language</a>.</li>
</ul>
<ul>
<li><a href="/wiki/IBM.html" title="IBM">IBM</a>'s open source adaptive <a href="/wiki/Java_virtual_machine.html" title="Java virtual machine">Java virtual machine</a>, <a  class="external text" title="http://jikesrvm.sourceforge.net/">Jikes RVM</a>, uses extended Array SSA, an extension of SSA that allows analysis of scalars, arrays, and object fields in a unified framework. Extended Array SSA analysis is only enabled at the maximum optimization level, which is applied to the most frequently executed portions of code.</li>
</ul>
<ul>
<li>In 2002, <a  class="external text" title="http://citeseer.ist.psu.edu/721276.html">researchers modified</a> IBM's JikesRVM (named Jalapeño at the time) to run both standard Java <a href="/wiki/Byte-code.html" title="Byte-code">byte-code</a> and a typesafe SSA (<a href="/wiki/SafeTSA.html" title="SafeTSA">SafeTSA</a>) byte-code class files, and demonstrated significant performance benefits to using the SSA byte-code.</li>
</ul>
<ul>
<li><a href="/wiki/Sun_Microsystem.html" title="Sun Microsystem">Sun Microsystem</a>'s <a href="/wiki/Java_HotSpot_Virtual_Machine.html" title="Java HotSpot Virtual Machine">Java HotSpot Virtual Machine</a> uses an SSA-based intermediate language in its JIT compiler.</li>
</ul>
<ul>
<li><a  class="external text" title="http://jackcc.sf.net">jackcc</a> is an open-source compiler for the academic instruction set Jackal 3.0. It uses a simple 3-operand code with SSA for its intermediate representation. As an interesting variant, it replaces Φ functions with a so-called SAME instruction, which instructs the register allocator to place the two live ranges into the same physical register.</li>
</ul>
<ul>
<li>Although not a compiler, the <a  class="external text" title="http://boomerang.sourceforge.net/">Boomerang</a> <a href="/wiki/Decompiler.html" title="Decompiler">decompiler</a> uses SSA form in its internal representation. SSA is used to simplify expression propagation, identifying parameters and returns, preservation analysis, and more.</li>
</ul>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: References">edit</a>]</div>
<p><a name="References" id="References"></a></p>
<h2>References</h2>
<ul>
<li><cite class="book" style="font-style:normal">Appel, Andrew W. (1999). <i>Modern Compiler Implementation in ML</i>. Cambridge University Press. <a  class="internal">ISBN 0-521-58274-1</a>.</cite> Also available in <a href="/wiki/Java_programming_language.html" title="Java programming language">Java</a> (<a  class="internal">ISBN 0-521-82060-X</a> 2002) and <a href="/wiki/C_programming_language.html" title="C programming language">C</a> (<a  class="internal">ISBN 0-521-60765-5</a> 1998) versions.</li>
<li><cite class="book" style="font-style:normal">Cooper, Keith D.; &amp; Torczon, Linda. (2003). <i>Engineering a Compiler</i>. Morgan Kaufmann. <a  class="internal">ISBN 1-55860-698-X</a>.</cite></li>
<li><cite class="book" style="font-style:normal">Muchnick, Steven S. (1997). <i>Advanced Compiler Design and Implementation</i>. Morgan Kaufmann. <a  class="internal">ISBN 1-55860-320-4</a>.</cite></li>
</ul>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: See also">edit</a>]</div>
<p><a name="See_also" id="See_also"></a></p>
<h2>See also</h2>
<ul>
<li><a href="/wiki/Compiler_optimization.html" title="Compiler optimization">Compiler optimization</a></li>
</ul>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: External links">edit</a>]</div>
<p><a name="External_links" id="External_links"></a></p>
<h2>External links</h2>
<ul>
<li>Steven Bosscher and Diego Novillo. <a  class="external text" title="http://lwn.net/Articles/84888/">GCC gets a new Optimizer Framework</a>. An article about GCC's use of SSA and how it improves over older IRs.</li>
<li><a  class="external text" title="http://www.cs.man.ac.uk/~jsinger/ssa.html">The SSA Bibliography</a>. Extensive catalogue of SSA research papers.</li>
</ul>

<!-- 
Pre-expand include size: 7958 bytes
Post-expand include size: 1585 bytes
Template argument size: 2254 bytes
Maximum: 2048000 bytes
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:373371-0!1!0!default!!en!2 and timestamp 20060910160059 -->
<div class="printfooter">
Retrieved from "<a </div>
			<div id="catlinks"><p class='catlinks'><a  title="Special:Categories">Category</a>: <span dir='ltr'><a  title="Category:Compiler theory">Compiler theory</a></span></p></div>			<!-- end content -->
			<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<ul>
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Static_single_assignment_form.html">Article</a></li>
				 <li id="ca-talk"><a >Discussion</a></li>
				 <li id="ca-edit"><a >Edit this page</a></li>
				 <li id="ca-history"><a >History</a></li>
		</ul>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a >Sign in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(/images/wiki-en.png);" href="/wiki/Main_Page.html" title="Main Page"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage"><a href="/wiki/Main_Page.html">Main Page</a></li>
				<li id="n-portal"><a >Community Portal</a></li>
				<li id="n-Featured-articles"><a >Featured articles</a></li>
				<li id="n-currentevents"><a >Current events</a></li>
				<li id="n-recentchanges"><a >Recent changes</a></li>
				<li id="n-randompage"><a >Random article</a></li>
				<li id="n-help"><a >Help</a></li>
				<li id="n-contact"><a >Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a >Donations</a></li>
			</ul>
		</div>
	</div>
		<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/wiki/Special:Search" id="searchform"><div>
				<input id="searchInput" name="search" type="text" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" value="Search" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a >What links here</a></li>
				<li id="t-recentchangeslinked"><a >Related changes</a></li>
<li id="t-upload"><a >Upload file</a></li>
<li id="t-specialpages"><a >Special pages</a></li>
				<li id="t-print"><a >Printable version</a></li>				<li id="t-permalink"><a >Permanent link</a></li><li id="t-cite"><a >Cite this article</a></li>			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a ><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="MediaWiki" /></a></div>
				<div id="f-copyrightico"><a ><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
				<li id="lastmod"> This page was last modified 06:31, 9 September 2006.</li>
				<li id="copyright">All text is available under the terms of the <a class='internal'  title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal'  title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the Wikimedia Foundation, Inc.<br /></li>
				<li id="privacy"><a  title="wikimedia:Privacy policy">Privacy policy</a></li>
				<li id="about"><a  title="Wikipedia:About">About Wikipedia</a></li>
				<li id="disclaimer"><a  title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
		
	
		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
</div>
<!-- Served by srv41 in 1.146 secs. --></body></html>
