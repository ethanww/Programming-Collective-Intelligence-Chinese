<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="keywords" content="Virtual memory,1959,1962,1969,1990,32-bit,64-bit,Address space,Apple Macintosh,Application software,Atlas Computer" />
<link rel="shortcut icon"  />
<link rel="search" type="application/opensearchdescription+xml"  />
<link rel="copyright"  />
		<title>Virtual memory - Wikipedia, the free encyclopedia</title>
		<style type="text/css" media="screen,projection">/*<![CDATA[*/ @import "/skins-1.5/monobook/main.css?9"; /*]]>*/</style>
		<link rel="stylesheet" type="text/css" media="print"  />
		<!--[if lt IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE50Fixes.css";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE55Fixes.css";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/skins-1.5/monobook/IE60Fixes.css";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/skins-1.5/monobook/IE70Fixes.css?1";</style><![endif]-->
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
		
		<script type= "text/javascript">
			var skin = "monobook";
			var stylepath = "/skins-1.5";

			var wgArticlePath = "/wiki/$1";
			var wgScriptPath = "/w";
			var wgServer = "http://en.wikipedia.org";
                        
			var wgCanonicalNamespace = "";
			var wgNamespaceNumber = 0;
			var wgPageName = "Virtual_memory";
			var wgTitle = "Virtual memory";
			var wgArticleId = 32354;
			var wgIsArticle = true;
                        
			var wgUserName = null;
			var wgUserLanguage = "en";
			var wgContentLanguage = "en";
		</script>
		                
		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?1"><!-- wikibits js --></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js"><!-- site js --></script>
		<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Common.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=MediaWiki:Monobook.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=-&action=raw&gen=css&maxage=2678400";
/*]]>*/</style>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js"></script>
	</head>
<body  class="mediawiki ns-0 ltr">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><div style="text-align:right; font-size:80%">Your <b><a  class="extiw" title="wikimedia:Fundraising">continued donations</a></b> keep Wikipedia running!&nbsp;&nbsp;&nbsp;&nbsp;</div>
</div>		<h1 class="firstHeading">Virtual memory</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a >navigation</a>, <a >search</a></div>			<!-- start content -->
			<table class="messagebox merge">
<tr>
<td align="left"><a  class="image" title="Image:Split-arrows.gif"><img src="http://upload.wikimedia.org/wikipedia/commons/e/e0/Split-arrows.gif" alt="Image:Split-arrows.gif" width="60" height="20" longdesc="/wiki/Image:Split-arrows.gif" /></a></td>
<td align="center">It has been suggested that this article be split into multiple distinct articles. (<a  title="Talk:Virtual memory">Discuss</a>)</td>
</tr>
</table>
<div class="thumb tright">
<div style="width:302px;"><a  class="internal" title="The memory pages of the virtual address space seen by the process, may reside non-contiguously in primary, or even secondary storage."><img src="http://upload.wikimedia.org/wikipedia/en/thumb/b/b9/Virtualmem.png/300px-Virtualmem.png" alt="The memory pages of the virtual address space seen by the process, may reside non-contiguously in primary, or even secondary storage." width="300" height="353" longdesc="/wiki/Image:Virtualmem.png" /></a>
<div class="thumbcaption">
<div class="magnify" style="float:right"><a  class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="Enlarge" /></a></div>
The memory pages of the virtual address space seen by the process, may reside non-contiguously in primary, or even secondary storage.</div>
</div>
</div>
<p><b>Virtual memory</b> or <b>virtual memory addressing</b> is a memory management technique, used by <a href="/wiki/Computer_multitasking.html" title="Computer multitasking">multitasking</a> <a href="/wiki/Computer.html" title="Computer">computer</a> <a href="/wiki/Operating_system.html" title="Operating system">operating systems</a> wherein non-contiguous memory is presented to a software (aka <a href="/wiki/Process_%28computing%29.html" title="Process (computing)">process</a>) as contiguous memory. This contiguous memory is referred to as the <a href="/wiki/Virtual_address_space.html" title="Virtual address space">virtual address space</a>.</p>
<p>Virtual memory addressing is typically used in <a href="/wiki/Paging.html" title="Paging">paged memory</a> systems. This in turn is often combined with <i>memory swapping</i> (also known as <i>anonymous memory paging</i>), whereby memory pages stored in <a href="/wiki/Primary_storage.html" title="Primary storage">primary storage</a> are written to <a href="/wiki/Secondary_storage.html" title="Secondary storage">secondary storage</a> (often to a <i>swap file</i> or <i>swap partition</i>), thus freeing faster primary storage for other processes to use.</p>
<p>In technical terms, virtual memory allows software to run in a memory <a href="/wiki/Address_space.html" title="Address space">address space</a> whose size and addressing are not necessarily tied to the computer's physical memory. To properly implement virtual memory the CPU (or a device attached to it) must provide a way for the operating system to map virtual memory to physical memory and for it to detect when an address is required that does not currently relate to main memory so that the needed data can be swapped in. While it would certainly be possible to provide virtual memory without the <a href="/wiki/Central_processing_unit.html" title="Central processing unit">CPU's</a> assistance it would essentially require emulating a CPU that did provide the needed features.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a ><span class="tocnumber">1</span> <span class="toctext">Background</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">2</span> <span class="toctext">Paging</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">3</span> <span class="toctext">Details</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">4</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">5</span> <span class="toctext">Windows example</span></a>
<ul>
<li class="toclevel-2"><a ><span class="tocnumber">5.1</span> <span class="toctext">Fragmentation of the Windows page file</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a ><span class="tocnumber">6</span> <span class="toctext">Swapping in the Linux and BSD operating systems</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">7</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">8</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">9</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a ><span class="tocnumber">10</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<p><script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script></p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Background">edit</a>]</div>
<p><a name="Background" id="Background"></a></p>
<h2>Background</h2>
<p>Most computers possess four kinds of memory: <a href="/wiki/Processor_register.html" title="Processor register">registers</a> in the CPU, <a href="/wiki/CPU_cache.html" title="CPU cache">CPU caches</a> (generally some kind of <a href="/wiki/Static_random_access_memory.html" title="Static random access memory">static RAM</a>) both inside and adjacent to the CPU, <a href="/wiki/Main_memory.html" title="Main memory">main memory</a> (generally <a href="/wiki/Dynamic_random_access_memory.html" title="Dynamic random access memory">dynamic RAM</a>) which the CPU can read and write to directly and reasonably quickly; and <a href="/wiki/Disk_storage.html" title="Disk storage">disk storage</a>, which is much slower, but much larger. CPU register use is generally handled by the compiler and this isn't a huge burden as data doesn't generally stay in them very long (in the sense of usage). The decision of when to use cache and when to use main memory is generally dealt with by hardware so generally both are regarded together by the programmer as simply <a href="/wiki/Physical_memory.html" title="Physical memory">physical memory</a>.</p>
<p>Many <a href="/wiki/Application_software.html" title="Application software">applications</a> require access to more information (<a href="/wiki/Code_%28computer_programming%29.html" title="Code (computer programming)">code</a> as well as data) than can be stored in physical memory. This is especially true when the operating system allows multiple processes/<a href="/wiki/Application_software.html" title="Application software">applications</a> to run seemingly in parallel. The obvious response to the problem of the maximum size of the physical memory being less than that required for all running programs is for the application to keep some of its information on the disk, and move it back and forth to physical memory as needed, but there are a number of ways to do this.</p>
<p>One option is for the application software itself to be responsible both for deciding which information is to be kept where, and also for moving it back and forth. The programmer would do this by determining which sections of the program (and also its data) were <a href="/wiki/Mutually_exclusive.html" title="Mutually exclusive">mutually exclusive</a>, and then arranging for loading and unloading the appropriate sections from physical memory, as needed. The disadvantage of this approach is that each application's <a href="/wiki/Programmer.html" title="Programmer">programmer</a> must spend time and effort on designing, implementing, and <a href="/wiki/Debugging.html" title="Debugging">debugging</a> this mechanism, instead of focusing on his or her application; this hampers programmers' efficiency. Also, if any programmer could truly choose which of their items of data to store in the physical memory at any one time, they could easily conflict with the decisions made by another programmer, who also wanted to use all the available physical memory at that point.</p>
<p>Another option is to store some form of handles to data rather than direct pointers and let the OS deal with swapping the data associated with those handles between the swap area and physical memory as needed. This works but has a couple of problems, namely that it complicates application code, that it requires applications to play nice (they generally need the power to lock the data into physical memory to actually work on it) and that it stops the languages standard library doing its own suballocations inside large blocks from the OS to improve performance. The best known example of this kind of arrangement is probably the <a href="/wiki/Windows_3.x.html" title="Windows 3.x">16-bit versions of Windows</a>.</p>
<p>The modern solution is to use virtual memory, in which a combination of special <a href="/wiki/Computer_hardware.html" title="Computer hardware">hardware</a> and <a href="/wiki/Operating_system.html" title="Operating system">operating system</a> software makes use of both kinds of memory to make it look as if the computer has a much larger main memory than it actually does and to lay that space out differently at will. It does this in a way that is invisible to the rest of the software running on the computer. It usually provides the ability to simulate a main memory of almost any size (In practice there's a limit imposed on this by the size of the addresses. For a <a href="/wiki/32-bit.html" title="32-bit">32-bit</a> system, the total size of the virtual memory can be 2<sup>32</sup>, or approximately 4 gigabytes. For the newer <a href="/wiki/64-bit.html" title="64-bit">64-bit</a> chips and operating systems that use 64 or 48 bit addresses, this can be much higher. Many operating systems do not allow the entire address space to be used by applications to simplify kernel access to application memory but this is not a hard design requirement.)</p>
<p>Virtual memory makes the job of the application programmer much simpler. No matter how much memory the application needs, it can act as if it has access to a main memory of that size and can place its data wherever in that virtual space that it likes. The programmer can also completely ignore the need to manage the moving of data back and forth between the different kinds of memory. Having said that if the programmer cares about performance when working with large volumes of data they need to minimise the number of blocks that are being accessed close together to avoid unnecessary swapping.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Paging">edit</a>]</div>
<p><a name="Paging" id="Paging"></a></p>
<h2>Paging</h2>
<p>Virtual memory is usually (but not necessarily) implemented using <a href="/wiki/Paging.html" title="Paging">paging</a>. In paging, the low order bits of the binary representation of the virtual address are preserved, and used directly as the low order bits of the actual physical address; the high order bits are treated as a key to one or more address translation tables, which provide the high order bits of the actual physical address.</p>
<p>For this reason a range of consecutive addresses in the <a href="/wiki/Virtual_address_space.html" title="Virtual address space">virtual address space</a> whose size is a <a href="/wiki/Power_of_two.html" title="Power of two">power of two</a> will be translated in a corresponding range of consecutive physical addresses. The memory referenced by such a range is called a <i>page</i>. The page size is typically in the range of 512 to 8192 bytes (with 4K currently being very common), though page sizes of 4 megabytes or larger may be used for special purposes. (Using the same or a related mechanism, contiguous regions of virtual memory larger than a page are often mappable to contiguous physical memory for purposes other than virtualization, such as setting access and caching control bits.)</p>
<p>The operating system stores the address translation tables, the mappings from virtual to physical page numbers, in a data structure known as a <a href="/wiki/Page_table.html" title="Page table">page table</a>.</p>
<p>If a page that is marked as unavailable (perhaps because it is not present in physical memory, but instead is in the swap area), when the CPU tries to reference a memory location in that page, the MMU responds by raising an exception (commonly called a <i>page fault</i>) with the CPU, which then jumps to a routine in the operating system. If the page is in the swap area, this routine invokes an operation called a <i>page swap</i>, to bring in the required page.</p>
<p>The page swap operation involves a series of steps. First it selects a page in memory, for example, a page that has not been recently accessed and (preferably) has not been modified since it was last read from disk or the swap area. (See <a href="/wiki/Page_replacement_algorithms.html" title="Page replacement algorithms">page replacement algorithms</a> for details.) If the page has been modified, the process writes the modified page to the swap area. The next step in the process is to read in the information in the needed page (the page corresponding to the virtual address the original program was trying to reference when the exception occurred) from the swap file. When the page has been read in, the tables for translating virtual addresses to physical addresses are updated to reflect the revised contents of the physical memory. Once the page swap completes, it exits, and the program is restarted and continues on as if nothing had happened, returning to the point in the program that caused the exception.</p>
<p>It is also possible that a virtual page was marked as unavailable because the page was never previously allocated. In such cases, a page of physical memory is allocated and filled with zeros, the page table is modified to describe it, and the program is restarted as above.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Details">edit</a>]</div>
<p><a name="Details" id="Details"></a></p>
<h2>Details</h2>
<p>The translation from virtual to physical addresses is implemented by an <a href="/wiki/Memory_management_unit.html" title="Memory management unit">MMU</a> (Memory Management Unit). This may be either a module of the CPU, or an auxiliary, closely coupled chip.</p>
<p>The operating system is responsible for deciding which parts of the program's simulated main memory are kept in physical memory. The operating system also maintains the translation tables which provide the mappings between virtual and physical addresses, for use by the MMU. Finally, when a virtual memory exception occurs, the operating system is responsible for allocating an area of physical memory to hold the missing information (and possibly in the process pushing something else out to disk), bringing the relevant information in from the disk, updating the translation tables, and finally resuming execution of the software that incurred the virtual memory exception.</p>
<p>In most computers, these translation tables are stored in physical memory. Therefore, a virtual memory reference might actually involve two or more physical memory references: one or more to retrieve the needed address translation from the page tables, and a final one to actually do the memory reference.</p>
<p>To minimize the performance penalty of address translation, most modern CPUs include an on-chip MMU, and maintain a table of recently used virtual-to-physical translations, called a <a href="/wiki/Translation_Lookaside_Buffer.html" title="Translation Lookaside Buffer">Translation Lookaside Buffer</a>, or TLB. Addresses with entries in the TLB require no additional memory references (and therefore time) to translate, However, the TLB can only maintain a fixed number of mappings between virtual and physical addresses; when the needed translation is not resident in the TLB, action will have to be taken to load it in.</p>
<p>On some processors, this is performed entirely in hardware; the MMU has to do additional memory references to load the required translations from the translation tables, but no other action is needed. In other processors, assistance from the operating system is needed; an exception is raised, and on this exception, the operating system replaces one of the entries in the TLB with an entry from the translation table, and the instruction which made the original memory reference is restarted.</p>
<p>The hardware that supports virtual memory almost always supports memory protection mechanisms as well. The MMU may have the ability to vary its operation according to the type of memory reference (for read, write or execution), as well as the privilege mode of the CPU at the time the memory reference was made. This allows the operating system to protect its own code and data (such as the translation tables used for virtual memory) from corruption by an erroneous application program and to protect application programs from each other and (to some extent) from themselves (e.g. by preventing writes to areas of memory which contain code).</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: History">edit</a>]</div>
<p><a name="History" id="History"></a></p>
<h2>History</h2>
<p>Before the development of the virtual memory technique, programmers in the 1940s and 1950s had to manage two-level storage (main memory or RAM, and secondary memory in the form of <a href="/wiki/Hard_disks.html" title="Hard disks">hard disks</a> or earlier, <a href="/wiki/Magnetic_drum.html" title="Magnetic drum">magnetic drums</a>) directly.</p>
<p>Virtual memory was developed in approximately <a href="/wiki/1959.html" title="1959">1959</a> - <a href="/wiki/1962.html" title="1962">1962</a>, at the <a href="/wiki/University_of_Manchester.html" title="University of Manchester">University of Manchester</a> for the <a href="/wiki/Atlas_Computer.html" title="Atlas Computer">Atlas Computer</a>, completed in <a href="/wiki/1962.html" title="1962">1962</a>. However, Fritz-Rudolf Güntsch, one of Germany's pioneering computer scientists and later the developer of the <a href="/wiki/Telefunken.html" title="Telefunken">Telefunken</a> TR 440 mainframe, claims to have invented the concept in his doctoral dissertation <i>Logischer Entwurf eines digitalen Rechengerätes mit mehreren asynchron laufenden Trommeln und automatischem Schnellspeicherbetrieb</i> (Logic Concept of a Digital Computing Device with Multiple Asynchronous Drum Storage and Automatic Fast Memory Mode) in 1957.</p>
<p>In 1961, <a href="/wiki/Burroughs.html" title="Burroughs">Burroughs</a> released the <a href="/wiki/B5000.html" title="B5000">B5000</a> the first commercial computer with virtual memory.</p>
<p>Like many technologies in the history of computing, virtual memory was not accepted without challenge. Before it could be regarded as a stable entity, many models, experiments, and theories had to be developed to overcome the numerous problems with virtual memory. Specialized hardware had to be developed that would take a "virtual" address and translate it into an actual physical address in memory (secondary or primary). Some worried that this process would be expensive, hard to build, and take too much processor power to do the address translation.<sup title="The text in the vicinity of this tag needs citation." class="noprint">[<a  title="Wikipedia:Citing sources"><i>citation&#160;needed</i></a>]</sup></p>
<p>By <a href="/wiki/1969.html" title="1969">1969</a> the debates over virtual memory for commercial computers were over<sup title="The text in the vicinity of this tag needs citation." class="noprint">[<a  title="Wikipedia:Citing sources"><i>citation&#160;needed</i></a>]</sup>. An <a href="/wiki/IBM.html" title="IBM">IBM</a> research team, lead by David Sayre, showed that the virtual memory overlay system worked consistently better than the best manual-controlled systems.</p>
<p>In the 1970s, <a href="/wiki/Minicomputer.html" title="Minicomputer">minicomputer</a> models such as <a href="/wiki/VAX.html" title="VAX">VAX</a> models running <a href="/wiki/OpenVMS.html" title="OpenVMS">VMS</a> implemented virtual memory.</p>
<p>Nevertheless, early personal computers in the 1980s were developed without virtual memory, on the assumption that such issues would only apply to large-scale commercial computers<sup title="The text in the vicinity of this tag needs citation." class="noprint">[<a  title="Wikipedia:Citing sources"><i>citation&#160;needed</i></a>]</sup>. Virtual memory based on swap files was introduced for <a href="/wiki/Microsoft_Windows.html" title="Microsoft Windows">Microsoft Windows</a> in <a href="/wiki/Windows_3.0.html" title="Windows 3.0">Windows 3.0</a> (1990), the <a href="/wiki/Apple_Macintosh.html" title="Apple Macintosh">Apple Macintosh</a> starting with <a href="/wiki/System_7_%28Macintosh%29.html" title="System 7 (Macintosh)">System 7</a> (1991) and the <a href="/wiki/Linux_Kernel.html" title="Linux Kernel">Linux Kernel</a> version 0.11+VM (1991).</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Windows example">edit</a>]</div>
<p><a name="Windows_example" id="Windows_example"></a></p>
<h2>Windows example</h2>
<p>Virtual memory has been a feature of <a href="/wiki/Microsoft_Windows.html" title="Microsoft Windows">Microsoft Windows</a> since <a href="/wiki/Windows_3.0.html" title="Windows 3.0">Windows 3.0</a> in <a href="/wiki/1990.html" title="1990">1990</a>; it was done in an attempt to slash the system requirements for the operating system in response to the failures of <a href="/wiki/Windows_1.0.html" title="Windows 1.0">Windows 1.0</a> and <a href="/wiki/Windows_2.0.html" title="Windows 2.0">Windows 2.0</a> respectively. 386SPART.PAR or WIN386.SWP is a hidden file created by Windows 3.x for use as a virtual memory swap file. It is generally found in the <a href="/wiki/Root_directory.html" title="Root directory">root directory</a>, but it may appear elsewhere (typically in the WINDOWS directory). Its size depends on how much virtual memory the system has set up under <a href="/wiki/Windows_Control_Panel.html" title="Windows Control Panel">Control Panel</a> - Enhanced under "Virtual Memory". If a user moves or deletes this file, Windows will <a href="/wiki/Blue_Screen_of_Death.html" title="Blue Screen of Death">BSoD</a> the next time it is started with "The permanent swap file is corrupt" and will ask the user if he wants to delete the file (It asks this question whether or not the file exists).</p>
<p><a href="/wiki/Windows_95.html" title="Windows 95">Windows 95</a> uses a similar file and the controls for it are located under Control Panel - System - Performance tab - Virtual Memory. Windows automatically sets the page file to start 1.5x physical memory, and expand up to 3x physical memory if necessary. If a user runs memory intensive applications on a low physical memory system, it is preferable to manually set these sizes to a value higher than default.</p>
<p>Under NT-based versions of Windows (including <a href="/wiki/Windows_2000.html" title="Windows 2000">Windows 2000</a> and <a href="/wiki/Windows_XP.html" title="Windows XP">Windows XP</a>) the name is pagefile.sys. The default location of the page file is in the root directory of the partition where Windows is installed. Windows can be configured to use free space on any available drives for page files.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Fragmentation of the Windows page file">edit</a>]</div>
<p><a name="Fragmentation_of_the_Windows_page_file" id="Fragmentation_of_the_Windows_page_file"></a></p>
<h3>Fragmentation of the Windows page file</h3>
<p>Some believe that a page file can become heavily fragmented and cause performance issues. The common advice given to avoid this problem is to set a single "locked" page file size so that Windows will not resize the page file. Other people believe this to be problematic in the case that a Windows application requests more memory than the total size of physical and virtual memory. In this case, memory is not successfully allocated and programs (including Windows) may crash. Supporters of this view will note that the page file is rarely read or written in sequential order, so the performance advantages of having a completely sequential page file is minimal. It is however, generally agreed that a large page file will allow use of memory-heavy applications, and there is no penalty except that more disk space is used.</p>
<p><a href="/wiki/Defragment.html" title="Defragment">Defragmenting</a> the page file is also occasionally recommended to increase performance when a Windows system is chronically using much more memory than its total physical memory. In this case, while a defragged page file can help slightly, performance concerns are much more effectively dealt with by adding more physical memory.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Swapping in the Linux and BSD operating systems">edit</a>]</div>
<p><a name="Swapping_in_the_Linux_and_BSD_operating_systems" id="Swapping_in_the_Linux_and_BSD_operating_systems"></a></p>
<h2>Swapping in the Linux and BSD operating systems</h2>
<p>In the <a href="/wiki/Linux.html" title="Linux">Linux</a> and <a href="/wiki/Berkeley_Software_Distribution.html" title="Berkeley Software Distribution">*BSD</a> operating systems, it is common to use a whole partition of a HDD for swapping. Though it is still possible to use a file for this, it is recommended to use a separate partition, because this excludes chances of <a href="/wiki/Fragmentation_%28computer%29.html" title="Fragmentation (computer)">fragmentation</a>, which would reduce performance. Also, by using a separate swap partition, it can be guaranteed that the swap region is at the fastest location of the disk. On current HDDs this is the beginning.</p>
<p>Linux supports using a virtually unlimited number of swapping devices, each of which can be assigned a priority. When the operating system needs to swap pages out of physical memory, it uses the highest priority device with free space. If multiple devices are assigned the same priority, they are used in a fashion similar to level 0 <a href="/wiki/Redundant_array_of_independent_disks.html" title="Redundant array of independent disks">RAID</a> arrangements. This gives increased performance as long as the devices can be accessed efficiently in parallel - therefore, care should be taken assigning the priorities. For example, swaps located on the same physical disk shouldn't be used in parallel, but in order ranging from the fastest to the slowest ie. the fastest having the highest priority.</p>
<p>There are also some successful <a  class="external text" title="http://hedera.linuxnews.pl/_news/2002/09/03/_long/1445.html">attempts</a> to use the memory located on the <a href="/wiki/Graphics_card.html" title="Graphics card">graphics card</a> for swapping on Linux, as modern graphics cards often have 128 or even 256 megabytes of RAM which normally only gets put to use when playing games. Video memory being significantly faster than HDDs, this method gives excellent swapping performance.</p>
<p>Recently, some experimental improvements to the 2.6 <a href="/wiki/Linux_kernel.html" title="Linux kernel">Linux kernel</a> have been made by <a href="/wiki/Con_Kolivas.html" title="Con Kolivas">Con Kolivas</a>, published in his popular <a  class="external text" title="http://kernel.kolivas.org">CK patchset</a>. The improvements, called "Swap Prefetch", employ a mechanism of pre-fetching previously swapped pages back to physical memory even before they are actually needed, as long as the system is relatively idle (so not to impair performance) and there is available physical memory to use. This gives several orders of magnitude faster access to the affected pages when their owning process needs access to them, since they are effectively not swapped out by then.</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: See also">edit</a>]</div>
<p><a name="See_also" id="See_also"></a></p>
<h2>See also</h2>
<ul>
<li><a href="/wiki/Page_fault.html" title="Page fault">Page fault</a></li>
<li><a href="/wiki/CPU_design.html" title="CPU design">CPU design</a></li>
<li><a href="/wiki/Memory_management.html" title="Memory management">Memory management</a></li>
</ul>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: Notes">edit</a>]</div>
<p><a name="Notes" id="Notes"></a></p>
<h2>Notes</h2>
<ol class="references"></ol>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: References">edit</a>]</div>
<p><a name="References" id="References"></a></p>
<h2>References</h2>
<ul>
<li>John L. Hennessy, David A. Patterson, <i>Computer Architecture, A Quantitative Approach</i> (<a  class="internal">ISBN 1-55860-724-2</a>)</li>
</ul>
<div class="editsection" style="float:right;margin-left:5px;">[<a  title="Edit section: External links">edit</a>]</div>
<p><a name="External_links" id="External_links"></a></p>
<h2>External links</h2>
<ul>
<li><a  class="external text" title="http://www.techarp.com/showarticle.aspx?artno=143">Guide On Optimizing Virtual Memory Speed</a></li>
<li><a  class="external text" title="http://computer.howstuffworks.com/virtual-memory.htm">How Virtual Memory Works</a></li>
<li><a  class="external text" title="http://www.rojakpot.com/showarticle.aspx?artno=143&amp;pgno=1">Swap File vs. Paging File</a> (Hint: From Windows 95 onwards, all Windows OS versions use only paging files.)</li>
<li><a  class="external text" title="http://am.xs4all.nl/phpwiki/index.php/swap">Linux swap partition</a></li>
<li><a  class="external text" title="http://linux-mm.org/">Linux Memory Management</a></li>
<li><a  class="external text" title="http://www.pcnineoneone.com/howto/swpfile1.html">Windows swap file management</a></li>
<li><a  class="external text" title="http://people.msoe.edu/~mccrawt/resume/papers/CS384/mccrawt_cs384_virtual.pdf">Virtual Memory Page Replacement Algorithms</a></li>
<li><a  class="external text" title="http://gnulinuxclub.org/index.php?option=com_content&amp;task=view&amp;id=161&amp;Itemid=32">Linux Kernel Mailing List Discussion</a></li>
<li>Pointers to <a  class="external text" title="http://web-cat.cs.vt.edu/AlgovizWiki/VirtualMemory">virtual memory visualizations</a></li>
<li><a  class="external text" title="http://support.microsoft.com/kb/308417/">Windows XP. How to manually change the size of the virtual memory paging file</a></li>
<li><a  class="external text" title="http://support.microsoft.com/?id=312362">Windows XP. Factors that may deplete the supply of paged pool memory</a></li>
</ul>
<p><span class="boilerplate" id="foldoc"><i>This article was originally based on material from the <a href="/wiki/Free_On-line_Dictionary_of_Computing.html" title="Free On-line Dictionary of Computing">Free On-line Dictionary of Computing</a>, which is <a  title="Wikipedia:Foldoc license">licensed</a> under the <a href="/wiki/GNU_Free_Documentation_License.html" title="GNU Free Documentation License">GFDL</a>.</i></span></p>

<!-- 
Pre-expand include size: 4008 bytes
Post-expand include size: 1416 bytes
Template argument size: 56 bytes
Maximum: 2048000 bytes
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:32354-0!1!0!default!!en!2 and timestamp 20060910145110 -->
<div class="printfooter">
Retrieved from "<a </div>
			<div id="catlinks"><p class='catlinks'><a  title="Special:Categories">Categories</a>: <span dir='ltr'><a  title="Category:Articles to be split">Articles to be split</a></span> | <span dir='ltr'><a  title="Category:Articles with unsourced statements">Articles with unsourced statements</a></span> | <span dir='ltr'><a  title="Category:FOLDOC sourced articles">FOLDOC sourced articles</a></span> | <span dir='ltr'><a  title="Category:Virtual memory">Virtual memory</a></span></p></div>			<!-- end content -->
			<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<ul>
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Virtual_memory.html">Article</a></li>
				 <li id="ca-talk"><a >Discussion</a></li>
				 <li id="ca-edit"><a >Edit this page</a></li>
				 <li id="ca-history"><a >History</a></li>
		</ul>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a >Sign in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(/images/wiki-en.png);" href="/wiki/Main_Page.html" title="Main Page"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage"><a href="/wiki/Main_Page.html">Main Page</a></li>
				<li id="n-portal"><a >Community Portal</a></li>
				<li id="n-Featured-articles"><a >Featured articles</a></li>
				<li id="n-currentevents"><a >Current events</a></li>
				<li id="n-recentchanges"><a >Recent changes</a></li>
				<li id="n-randompage"><a >Random article</a></li>
				<li id="n-help"><a >Help</a></li>
				<li id="n-contact"><a >Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a >Donations</a></li>
			</ul>
		</div>
	</div>
		<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/wiki/Special:Search" id="searchform"><div>
				<input id="searchInput" name="search" type="text" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" value="Search" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a >What links here</a></li>
				<li id="t-recentchangeslinked"><a >Related changes</a></li>
<li id="t-upload"><a >Upload file</a></li>
<li id="t-specialpages"><a >Special pages</a></li>
				<li id="t-print"><a >Printable version</a></li>				<li id="t-permalink"><a >Permanent link</a></li><li id="t-cite"><a >Cite this article</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>In other languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-ca"><a >Català</a></li>
				<li class="interwiki-cs"><a >Česky</a></li>
				<li class="interwiki-da"><a >Dansk</a></li>
				<li class="interwiki-de"><a >Deutsch</a></li>
				<li class="interwiki-es"><a >Español</a></li>
				<li class="interwiki-fr"><a >Français</a></li>
				<li class="interwiki-gl"><a >Galego</a></li>
				<li class="interwiki-ko"><a >한국어</a></li>
				<li class="interwiki-it"><a >Italiano</a></li>
				<li class="interwiki-he"><a >עברית</a></li>
				<li class="interwiki-lt"><a >Lietuvių</a></li>
				<li class="interwiki-hu"><a >Magyar</a></li>
				<li class="interwiki-nl"><a >Nederlands</a></li>
				<li class="interwiki-ja"><a >日本語</a></li>
				<li class="interwiki-pl"><a >Polski</a></li>
				<li class="interwiki-pt"><a >Português</a></li>
				<li class="interwiki-ru"><a >Русский</a></li>
				<li class="interwiki-sk"><a >Slovenčina</a></li>
				<li class="interwiki-sl"><a >Slovenščina</a></li>
				<li class="interwiki-fi"><a >Suomi</a></li>
				<li class="interwiki-sv"><a >Svenska</a></li>
				<li class="interwiki-zh"><a >中文</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a ><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="MediaWiki" /></a></div>
				<div id="f-copyrightico"><a ><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
				<li id="lastmod"> This page was last modified 16:54, 28 August 2006.</li>
				<li id="copyright">All text is available under the terms of the <a class='internal'  title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal'  title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the Wikimedia Foundation, Inc.<br /></li>
				<li id="privacy"><a  title="wikimedia:Privacy policy">Privacy policy</a></li>
				<li id="about"><a  title="Wikipedia:About">About Wikipedia</a></li>
				<li id="disclaimer"><a  title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
		
	
		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
</div>
<!-- Served by srv119 in 0.082 secs. --></body></html>
